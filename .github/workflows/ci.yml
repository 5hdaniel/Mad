name: CI/CD

# Branching Strategy:
# - main: Production-ready code, triggers packaging/releases
# - develop: Integration branch for next release
# - feature/*, fix/*, claude/*: Feature branches
#
# Merge Policy: Always use traditional merges (not squash) to retain commit history

on:
  push:
    branches: [main, develop, 'feature/**', 'fix/**', 'claude/**', 'docs/**']
  pull_request:
    branches: [main, develop]

jobs:
  # Fast check to determine if we can skip heavy CI jobs
  check-changes:
    name: Check Changes
    runs-on: ubuntu-latest
    outputs:
      docs-only: ${{ steps.filter.outputs.docs-only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper branch comparison

      - name: Fetch base branch for PR comparison
        if: github.event_name == 'pull_request'
        run: git fetch origin ${{ github.base_ref }}

      - name: Check for docs-only changes
        id: filter
        run: |
          # Get changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          else
            CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD)
          fi

          echo "Changed files:"
          echo "$CHANGED"

          # Check if all changes are docs/markdown only
          DOCS_ONLY="true"
          while IFS= read -r file; do
            if [ -n "$file" ]; then
              case "$file" in
                *.md|.claude/*|docs/*|.github/ISSUE_TEMPLATE/*|.github/PULL_REQUEST_TEMPLATE/*|LICENSE|*.txt)
                  # Documentation file, continue
                  ;;
                *)
                  # Non-docs file found
                  DOCS_ONLY="false"
                  break
                  ;;
              esac
            fi
          done <<< "$CHANGED"

          echo "docs-only=$DOCS_ONLY" >> $GITHUB_OUTPUT
          echo "Result: docs-only=$DOCS_ONLY"

  # For docs-only changes, provide passing status checks without running heavy tests
  # Matrix must match the real test job to produce identical status check names
  docs-pass:
    name: Test & Lint
    needs: check-changes
    if: needs.check-changes.outputs.docs-only == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [macos-latest, windows-latest]
        node-version: [20.x]
    steps:
      - name: Skip tests (docs-only change)
        run: echo "Skipping tests for ${{ matrix.os }} / Node ${{ matrix.node-version }} - documentation-only changes detected"

  test:
    name: Test & Lint
    needs: check-changes
    if: needs.check-changes.outputs.docs-only != 'true'
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30  # Prevent CI from running indefinitely

    strategy:
      matrix:
        os: [macos-latest, windows-latest]
        node-version: [20.x]  # Node 18 dropped - better-sqlite3-multiple-ciphers requires Node 20+

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install

      - name: Rebuild native modules for Electron
        run: node scripts/rebuild-native.js

      - name: TypeScript type check
        run: npm run type-check

      - name: Run linter
        run: npm run lint
        continue-on-error: true

      - name: Run tests
        run: npm test -- --silent --maxWorkers=2 --workerIdleMemoryLimit=512MB --forceExit
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"

      - name: Upload coverage to Codecov
        if: matrix.os == 'macos-latest' && matrix.node-version == '20.x'
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  build:
    name: Build Application
    runs-on: ${{ matrix.os }}
    needs: [check-changes, test]
    if: needs.check-changes.outputs.docs-only != 'true'

    strategy:
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        run: npm install

      - name: Build Vite app
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.os }}
          path: dist/
          retention-days: 7

  # For docs-only changes, provide passing security check
  security-pass:
    name: Security Audit
    needs: check-changes
    if: needs.check-changes.outputs.docs-only == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Skip security audit (docs-only change)
        run: echo "Skipping security audit - documentation-only changes detected"

  security:
    name: Security Audit
    needs: check-changes
    if: needs.check-changes.outputs.docs-only != 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Check for outdated dependencies
        run: npm outdated
        continue-on-error: true

  # Package on main (production) and develop (staging) branches
  package:
    name: Package Application
    runs-on: ${{ matrix.os }}
    needs: [check-changes, test, build]
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && needs.check-changes.outputs.docs-only != 'true'

    strategy:
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        run: npm install

      - name: Build application
        run: npm run build

      - name: Package for macOS
        if: matrix.os == 'macos-latest'
        run: |
          echo "::group::Package Configuration"
          echo "Checking code signing configuration..."
          if [ -n "$MACOS_CERT" ]; then
            echo "✓ Code signing certificate: configured"
            echo "✓ Certificate password: $([ -n "$MACOS_CERT_PASSWORD" ] && echo 'configured' || echo 'not set')"
            echo "✓ Apple ID: $([ -n "$APPLE_ID" ] && echo 'configured' || echo 'not set')"
            echo "✓ Apple Team ID: $([ -n "$APPLE_TEAM_ID" ] && echo 'configured' || echo 'not set')"
            echo "::endgroup::"
            echo ""
            echo "Building signed package..."
            export CSC_LINK="$MACOS_CERT"
            export CSC_KEY_PASSWORD="$MACOS_CERT_PASSWORD"
            if ! npm run package 2>&1 | tee package.log; then
              echo "::error::Package build failed. Check package.log for details."
              cat package.log
              exit 1
            fi
          else
            echo "✗ Code signing certificate: not configured"
            echo "::warning::Building unsigned package - code signing secrets not configured"
            echo "::endgroup::"
            echo ""
            echo "Building unsigned package..."
            export CSC_IDENTITY_AUTO_DISCOVERY=false
            if ! npm run package:unsigned 2>&1 | tee package.log; then
              echo "::error::Unsigned package build failed. Check package.log for details."
              cat package.log
              exit 1
            fi
          fi
          echo ""
          echo "::group::Build Artifacts"
          ls -la dist/*.dmg dist/*.zip 2>/dev/null || echo "No package artifacts found"
          echo "::endgroup::"
        env:
          MACOS_CERT: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERT_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Download and extract Apple drivers (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          echo "Downloading iTunes installer to extract Apple Mobile Device Support..."

          # Download iTunes installer
          $iTunesUrl = "https://www.apple.com/itunes/download/win64"
          $installerPath = "$env:TEMP\iTunes64Setup.exe"
          $extractPath = "$env:TEMP\iTunes-extracted"
          $targetPath = "resources\win\apple-drivers"

          echo "Downloading from $iTunesUrl..."
          Invoke-WebRequest -Uri $iTunesUrl -OutFile $installerPath -UseBasicParsing

          echo "Download complete. Size: $((Get-Item $installerPath).Length / 1MB) MB"

          # Extract using 7-Zip (pre-installed on GitHub runners)
          echo "Extracting with 7-Zip..."
          7z x $installerPath -o"$extractPath" -y

          # Find the MSI
          echo "Looking for AppleMobileDeviceSupport MSI..."
          $msi = Get-ChildItem -Path $extractPath -Recurse -Filter "AppleMobileDeviceSupport*.msi" | Select-Object -First 1

          if ($msi) {
            echo "Found: $($msi.FullName)"

            # Ensure target directory exists
            New-Item -ItemType Directory -Force -Path $targetPath | Out-Null

            # Copy MSI to resources
            Copy-Item $msi.FullName -Destination "$targetPath\AppleMobileDeviceSupport64.msi"

            # Create version file
            $version = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($msi.FullName).FileVersion
            if (-not $version) { $version = "unknown" }
            Set-Content -Path "$targetPath\version.txt" -Value $version

            echo "Apple drivers extracted successfully!"
            echo "MSI: $targetPath\AppleMobileDeviceSupport64.msi"
            echo "Version: $version"
          } else {
            echo "::warning::Could not find AppleMobileDeviceSupport MSI in extracted files"
            echo "Extracted contents:"
            Get-ChildItem -Path $extractPath -Recurse | Select-Object FullName
          }

          # Cleanup
          Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
          Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
        shell: pwsh

      - name: Package for Windows
        if: matrix.os == 'windows-latest'
        run: |
          echo "Building Windows package..."
          npm run package:unsigned
          echo "Build complete. Checking artifacts..."
          Get-ChildItem -Path dist -Filter "*.exe" | Format-Table Name, Length
        shell: pwsh

      - name: Upload macOS package artifacts
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: packages-${{ matrix.os }}
          path: |
            dist/*.dmg
            dist/*.zip
          retention-days: 30

      - name: Upload Windows package artifacts
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: packages-${{ matrix.os }}
          path: |
            dist/*.exe
          retention-days: 30
