# EUM-003: Audit Logging Service

## Task Info
- **Task ID:** EUM-003
- **Phase:** 1 - Foundation
- **Dependencies:** None (can work with mock data until EUM-001 is merged)
- **Can Start:** Immediately
- **Parallel With:** EUM-001, EUM-002, EUM-004

## Goal

Create a service for logging all administrative actions in organizations, providing an audit trail for compliance and security monitoring.

## Background

Enterprise customers need visibility into who did what and when. This audit log captures all user management, SSO configuration, and SCIM provisioning events.

## Non-Goals

- ❌ Creating database schema (handled in EUM-001)
- ❌ Building UI components for viewing audit logs (handled in Phase 3)
- ❌ Implementing audit log retention/archival policies
- ❌ Real-time audit log streaming
- ❌ Modifying existing application logging
- ❌ Creating alerts based on audit events

## Deliverables

1. Audit service with logging and querying capabilities
2. TypeScript types for audit events
3. IPC handlers for renderer communication
4. Predefined action types for consistency
5. Unit tests

## Technical Requirements

### 1. Create Audit Types

Create `electron/types/audit.ts`:

```typescript
// Predefined action types
export const AUDIT_ACTIONS = {
  // User Actions
  USER_INVITED: 'user.invited',
  USER_JOINED: 'user.joined',
  USER_REMOVED: 'user.removed',
  USER_ROLE_CHANGED: 'user.role_changed',
  USER_SUSPENDED: 'user.suspended',
  USER_REACTIVATED: 'user.reactivated',

  // SSO Actions
  SSO_CONFIGURED: 'sso.configured',
  SSO_UPDATED: 'sso.updated',
  SSO_TESTED: 'sso.tested',
  SSO_ENABLED: 'sso.enabled',
  SSO_DISABLED: 'sso.disabled',
  SSO_ENFORCED: 'sso.enforced',
  SSO_UNENFORCED: 'sso.unenforced',

  // SCIM Actions
  SCIM_ENABLED: 'scim.enabled',
  SCIM_DISABLED: 'scim.disabled',
  SCIM_TOKEN_CREATED: 'scim.token_created',
  SCIM_TOKEN_REVOKED: 'scim.token_revoked',
  SCIM_USER_PROVISIONED: 'scim.user_provisioned',
  SCIM_USER_DEPROVISIONED: 'scim.user_deprovisioned',
  SCIM_USER_UPDATED: 'scim.user_updated',

  // Organization Actions
  ORG_CREATED: 'org.created',
  ORG_UPDATED: 'org.updated',
  ORG_DELETED: 'org.deleted',
  ORG_DOMAIN_ADDED: 'org.domain_added',
  ORG_DOMAIN_REMOVED: 'org.domain_removed',
  ORG_DOMAIN_VERIFIED: 'org.domain_verified',
  ORG_OWNERSHIP_TRANSFERRED: 'org.ownership_transferred',
} as const;

export type AuditAction = typeof AUDIT_ACTIONS[keyof typeof AUDIT_ACTIONS];

export const RESOURCE_TYPES = {
  USER: 'user',
  ORGANIZATION: 'organization',
  SSO_CONFIG: 'sso_configuration',
  SCIM_TOKEN: 'scim_token',
  DOMAIN: 'domain',
} as const;

export type ResourceType = typeof RESOURCE_TYPES[keyof typeof RESOURCE_TYPES];

export const ACTOR_TYPES = {
  USER: 'user',
  SYSTEM: 'system',
  SCIM: 'scim',
} as const;

export type ActorType = typeof ACTOR_TYPES[keyof typeof ACTOR_TYPES];

export interface AuditLogEntry {
  id: string;
  organizationId: string;

  // Actor info
  actorId: string | null;
  actorEmail: string | null;
  actorType: ActorType;

  // Action info
  action: AuditAction;
  resourceType: ResourceType;
  resourceId: string | null;

  // Details
  details: Record<string, any>;
  ipAddress: string | null;
  userAgent: string | null;

  // Timestamp
  createdAt: string;
}

export interface CreateAuditLogInput {
  organizationId: string;
  actorId?: string | null;
  actorEmail?: string | null;
  actorType?: ActorType;
  action: AuditAction;
  resourceType: ResourceType;
  resourceId?: string | null;
  details?: Record<string, any>;
  ipAddress?: string | null;
  userAgent?: string | null;
}

export interface AuditLogFilters {
  startDate?: string;
  endDate?: string;
  action?: AuditAction | AuditAction[];
  actorId?: string;
  resourceType?: ResourceType;
  resourceId?: string;
  search?: string;
}

export interface AuditLogPagination {
  page: number;
  pageSize: number;
}

export interface PaginatedAuditLogs {
  logs: AuditLogEntry[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}
```

### 2. Create Audit Service

Create `electron/services/auditService.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import log from 'electron-log';
import type {
  AuditLogEntry,
  CreateAuditLogInput,
  AuditLogFilters,
  AuditLogPagination,
  PaginatedAuditLogs,
  AuditAction,
  ResourceType,
  ActorType,
} from '../types/audit';
import { AUDIT_ACTIONS, RESOURCE_TYPES, ACTOR_TYPES } from '../types/audit';

export class AuditService {
  private supabase;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  /**
   * Log an audit event
   */
  async log(input: CreateAuditLogInput): Promise<AuditLogEntry> {
    const entry = {
      organization_id: input.organizationId,
      actor_id: input.actorId ?? null,
      actor_email: input.actorEmail ?? null,
      actor_type: input.actorType ?? ACTOR_TYPES.USER,
      action: input.action,
      resource_type: input.resourceType,
      resource_id: input.resourceId ?? null,
      details: input.details ?? {},
      ip_address: input.ipAddress ?? null,
      user_agent: input.userAgent ?? null,
    };

    const { data, error } = await this.supabase
      .from('audit_logs')
      .insert(entry)
      .select()
      .single();

    if (error) {
      log.error('Failed to create audit log:', error);
      throw new Error(`Failed to create audit log: ${error.message}`);
    }

    log.info(`Audit: ${input.action} by ${input.actorEmail || input.actorId || 'system'}`);
    return this.mapToAuditLogEntry(data);
  }

  /**
   * Get audit logs for an organization with filtering and pagination
   */
  async getLogs(
    organizationId: string,
    filters?: AuditLogFilters,
    pagination?: AuditLogPagination
  ): Promise<PaginatedAuditLogs> {
    const page = pagination?.page ?? 1;
    const pageSize = pagination?.pageSize ?? 50;
    const offset = (page - 1) * pageSize;

    let query = this.supabase
      .from('audit_logs')
      .select('*', { count: 'exact' })
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false });

    // Apply filters
    if (filters?.startDate) {
      query = query.gte('created_at', filters.startDate);
    }
    if (filters?.endDate) {
      query = query.lte('created_at', filters.endDate);
    }
    if (filters?.action) {
      if (Array.isArray(filters.action)) {
        query = query.in('action', filters.action);
      } else {
        query = query.eq('action', filters.action);
      }
    }
    if (filters?.actorId) {
      query = query.eq('actor_id', filters.actorId);
    }
    if (filters?.resourceType) {
      query = query.eq('resource_type', filters.resourceType);
    }
    if (filters?.resourceId) {
      query = query.eq('resource_id', filters.resourceId);
    }

    // Apply pagination
    query = query.range(offset, offset + pageSize - 1);

    const { data, error, count } = await query;

    if (error) {
      log.error('Failed to get audit logs:', error);
      throw new Error(`Failed to get audit logs: ${error.message}`);
    }

    const total = count ?? 0;

    return {
      logs: (data ?? []).map(this.mapToAuditLogEntry),
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize),
    };
  }

  /**
   * Get audit logs for a specific user across all their organizations
   */
  async getLogsForUser(
    userId: string,
    filters?: AuditLogFilters,
    pagination?: AuditLogPagination
  ): Promise<PaginatedAuditLogs> {
    const page = pagination?.page ?? 1;
    const pageSize = pagination?.pageSize ?? 50;
    const offset = (page - 1) * pageSize;

    let query = this.supabase
      .from('audit_logs')
      .select('*', { count: 'exact' })
      .eq('actor_id', userId)
      .order('created_at', { ascending: false });

    // Apply date filters
    if (filters?.startDate) {
      query = query.gte('created_at', filters.startDate);
    }
    if (filters?.endDate) {
      query = query.lte('created_at', filters.endDate);
    }

    // Apply pagination
    query = query.range(offset, offset + pageSize - 1);

    const { data, error, count } = await query;

    if (error) {
      log.error('Failed to get audit logs for user:', error);
      throw new Error(`Failed to get audit logs for user: ${error.message}`);
    }

    const total = count ?? 0;

    return {
      logs: (data ?? []).map(this.mapToAuditLogEntry),
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize),
    };
  }

  /**
   * Get audit logs for a specific resource
   */
  async getLogsForResource(
    organizationId: string,
    resourceType: ResourceType,
    resourceId: string,
    pagination?: AuditLogPagination
  ): Promise<PaginatedAuditLogs> {
    return this.getLogs(
      organizationId,
      { resourceType, resourceId },
      pagination
    );
  }

  /**
   * Export audit logs to CSV format
   */
  async exportLogs(
    organizationId: string,
    filters?: AuditLogFilters
  ): Promise<string> {
    // Get all logs (no pagination for export)
    const { data, error } = await this.supabase
      .from('audit_logs')
      .select('*')
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false });

    if (error) {
      throw new Error(`Failed to export audit logs: ${error.message}`);
    }

    const logs = (data ?? []).map(this.mapToAuditLogEntry);

    // Generate CSV
    const headers = [
      'Timestamp',
      'Action',
      'Actor Email',
      'Actor Type',
      'Resource Type',
      'Resource ID',
      'IP Address',
      'Details',
    ];

    const rows = logs.map((log) => [
      log.createdAt,
      log.action,
      log.actorEmail || '',
      log.actorType,
      log.resourceType,
      log.resourceId || '',
      log.ipAddress || '',
      JSON.stringify(log.details),
    ]);

    const csv = [
      headers.join(','),
      ...rows.map((row) =>
        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(',')
      ),
    ].join('\n');

    return csv;
  }

  /**
   * Get summary statistics for audit logs
   */
  async getStats(
    organizationId: string,
    startDate?: string,
    endDate?: string
  ): Promise<{
    totalEvents: number;
    eventsByAction: Record<string, number>;
    eventsByActor: Record<string, number>;
    recentActivity: AuditLogEntry[];
  }> {
    let query = this.supabase
      .from('audit_logs')
      .select('*')
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false });

    if (startDate) {
      query = query.gte('created_at', startDate);
    }
    if (endDate) {
      query = query.lte('created_at', endDate);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(`Failed to get audit stats: ${error.message}`);
    }

    const logs = data ?? [];

    // Calculate statistics
    const eventsByAction: Record<string, number> = {};
    const eventsByActor: Record<string, number> = {};

    logs.forEach((log) => {
      eventsByAction[log.action] = (eventsByAction[log.action] || 0) + 1;
      if (log.actor_email) {
        eventsByActor[log.actor_email] =
          (eventsByActor[log.actor_email] || 0) + 1;
      }
    });

    return {
      totalEvents: logs.length,
      eventsByAction,
      eventsByActor,
      recentActivity: logs.slice(0, 10).map(this.mapToAuditLogEntry),
    };
  }

  // ==================== Helper Methods ====================

  /**
   * Convenience method to log user events
   */
  async logUserEvent(
    organizationId: string,
    action: AuditAction,
    targetUserId: string,
    actorId: string,
    actorEmail: string,
    details?: Record<string, any>
  ): Promise<void> {
    await this.log({
      organizationId,
      actorId,
      actorEmail,
      actorType: ACTOR_TYPES.USER,
      action,
      resourceType: RESOURCE_TYPES.USER,
      resourceId: targetUserId,
      details,
    });
  }

  /**
   * Convenience method to log SSO events
   */
  async logSSOEvent(
    organizationId: string,
    action: AuditAction,
    actorId: string,
    actorEmail: string,
    details?: Record<string, any>
  ): Promise<void> {
    await this.log({
      organizationId,
      actorId,
      actorEmail,
      actorType: ACTOR_TYPES.USER,
      action,
      resourceType: RESOURCE_TYPES.SSO_CONFIG,
      resourceId: organizationId,
      details,
    });
  }

  /**
   * Convenience method to log SCIM events (system actor)
   */
  async logSCIMEvent(
    organizationId: string,
    action: AuditAction,
    resourceId?: string,
    details?: Record<string, any>
  ): Promise<void> {
    await this.log({
      organizationId,
      actorType: ACTOR_TYPES.SCIM,
      action,
      resourceType: RESOURCE_TYPES.USER,
      resourceId,
      details,
    });
  }

  private mapToAuditLogEntry(row: any): AuditLogEntry {
    return {
      id: row.id,
      organizationId: row.organization_id,
      actorId: row.actor_id,
      actorEmail: row.actor_email,
      actorType: row.actor_type,
      action: row.action,
      resourceType: row.resource_type,
      resourceId: row.resource_id,
      details: row.details || {},
      ipAddress: row.ip_address,
      userAgent: row.user_agent,
      createdAt: row.created_at,
    };
  }
}

// Singleton instance
let auditService: AuditService | null = null;

export function getAuditService(): AuditService {
  if (!auditService) {
    auditService = new AuditService(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    );
  }
  return auditService;
}
```

### 3. Create IPC Handlers

Create `electron/handlers/auditHandlers.ts`:

```typescript
import { ipcMain } from 'electron';
import { getAuditService } from '../services/auditService';
import log from 'electron-log';

export function registerAuditHandlers(): void {
  const auditService = getAuditService();

  ipcMain.handle('audit:get-logs', async (_, orgId, filters, pagination) => {
    try {
      const result = await auditService.getLogs(orgId, filters, pagination);
      return { success: true, data: result };
    } catch (error) {
      log.error('Failed to get audit logs:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('audit:get-logs-for-resource', async (_, orgId, resourceType, resourceId, pagination) => {
    try {
      const result = await auditService.getLogsForResource(orgId, resourceType, resourceId, pagination);
      return { success: true, data: result };
    } catch (error) {
      log.error('Failed to get audit logs for resource:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('audit:export', async (_, orgId, filters) => {
    try {
      const csv = await auditService.exportLogs(orgId, filters);
      return { success: true, data: csv };
    } catch (error) {
      log.error('Failed to export audit logs:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('audit:get-stats', async (_, orgId, startDate, endDate) => {
    try {
      const stats = await auditService.getStats(orgId, startDate, endDate);
      return { success: true, data: stats };
    } catch (error) {
      log.error('Failed to get audit stats:', error);
      return { success: false, error: error.message };
    }
  });
}
```

### 4. Update Preload Script

Add to `electron/preload.ts`:

```typescript
audit: {
  getLogs: (orgId: string, filters?: AuditLogFilters, pagination?: AuditLogPagination) =>
    ipcRenderer.invoke('audit:get-logs', orgId, filters, pagination),
  getLogsForResource: (orgId: string, resourceType: string, resourceId: string, pagination?: AuditLogPagination) =>
    ipcRenderer.invoke('audit:get-logs-for-resource', orgId, resourceType, resourceId, pagination),
  export: (orgId: string, filters?: AuditLogFilters) =>
    ipcRenderer.invoke('audit:export', orgId, filters),
  getStats: (orgId: string, startDate?: string, endDate?: string) =>
    ipcRenderer.invoke('audit:get-stats', orgId, startDate, endDate),
},
```

## Files to Create

- `electron/types/audit.ts`
- `electron/services/auditService.ts`
- `electron/handlers/auditHandlers.ts`
- `electron/services/__tests__/auditService.test.ts`

## Files to Modify

- `electron/preload.ts` - Add audit API
- `electron/main.ts` - Register audit handlers
- `src/types/electron.d.ts` - Add audit types

## Acceptance Criteria

- [ ] `log()` creates audit entry with all required fields
- [ ] `getLogs()` supports filtering by date range, action, actor, resource
- [ ] `getLogs()` supports pagination with page/pageSize
- [ ] `getLogsForResource()` returns logs for specific resource
- [ ] `exportLogs()` returns valid CSV with proper escaping
- [ ] `getStats()` calculates correct counts by action and actor
- [ ] All convenience methods (`logUserEvent`, `logSSOEvent`, `logSCIMEvent`) work correctly
- [ ] Failed audit log operations don't crash the application
- [ ] All IPC handlers return `{ success, data?, error? }` format
- [ ] Unit tests cover all public methods with >80% coverage

## When to Stop and Ask

You MUST stop and ask the PM if:

1. **Database schema mismatch** - If the `audit_logs` table from EUM-001 has different columns than expected
2. **Large dataset concerns** - If you believe the query patterns will be too slow for large audit logs
3. **CSV export limits** - If you need to implement pagination for exports to avoid memory issues
4. **Actor context** - If you're unsure how actor information (userId, email, IP) should be passed
5. **Action type additions** - If you believe new action types need to be added beyond what's specified
6. **RLS bypass needs** - If audit logging requires service role access that bypasses RLS

Do NOT guess or make assumptions. Ask first.

## Integration Notes

### For EUM-001 (Database Schema)
- Uses `audit_logs` table with RLS policies
- Admin/owner roles can view audit logs per RLS policy

### For EUM-002 (Organization Service)
- Organization service should call audit methods after successful operations
- Pass organization ID and actor context from IPC handlers

### For EUM-004 (RBAC Service)
- Audit log viewing requires `PERMISSIONS.AUDIT_VIEW`
- Audit log export requires `PERMISSIONS.AUDIT_EXPORT`

### For Phase 2+ (SSO, SCIM)
- SSO events use `logSSOEvent()` convenience method
- SCIM events use `logSCIMEvent()` with `actorType: 'scim'`
- All provisioning events should be logged

## Dos

- ✅ Use predefined action types for consistency
- ✅ Include actor information in all logs
- ✅ Support filtering by date range, action, actor
- ✅ Support CSV export for compliance
- ✅ Log audit failures (but don't crash the app)

## Don'ts

- ❌ Don't include sensitive data (passwords, tokens) in details
- ❌ Don't allow deletion of audit logs
- ❌ Don't modify existing audit log entries
- ❌ Don't skip audit logging on failures

## Testing Instructions

1. Unit test all service methods
2. Test filtering by various criteria
3. Test pagination
4. Test CSV export format
5. Test statistics calculation

## PR Preparation Checklist

Before completing, ensure:

- [ ] All action types defined
- [ ] All methods have error handling
- [ ] Unit tests with >80% coverage
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Tests pass: `npm test`
- [ ] Created pull request with summary

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
