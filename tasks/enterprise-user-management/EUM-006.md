# EUM-006: Microsoft Entra ID SSO Service

## Task Info
- **Task ID:** EUM-006
- **Phase:** 2 - SSO Implementation
- **Dependencies:** EUM-005 (Phase 1 complete)
- **Can Start:** After Phase 1 merge
- **Parallel With:** EUM-007, EUM-008, EUM-009

## Goal

Extend the existing Microsoft authentication to support enterprise SSO with Entra ID (formerly Azure AD), including tenant-specific authentication and group claims.

## Background

We already have `@azure/msal-node` integrated for individual Microsoft OAuth login. This task extends that to support enterprise SSO where an organization configures their Entra ID tenant for company-wide authentication.

## Deliverables

1. Entra ID SSO service extending existing Microsoft auth
2. Tenant-specific OIDC configuration
3. Group claims extraction
4. Domain verification
5. Unit tests

## Technical Requirements

### 1. Create Entra ID Types

Create `electron/types/entraId.ts`:

```typescript
export interface EntraIdConfig {
  tenantId: string;
  clientId: string;
  clientSecret: string; // Will be encrypted
  redirectUri: string;
}

export interface EntraIdTokenClaims {
  sub: string;           // User ID in Entra ID
  oid: string;           // Object ID
  email: string;
  name: string;
  given_name?: string;
  family_name?: string;
  preferred_username?: string;
  tid: string;           // Tenant ID
  groups?: string[];     // Group IDs if configured
  roles?: string[];      // App roles if configured
}

export interface EntraIdUserInfo {
  id: string;
  email: string;
  displayName: string;
  firstName: string | null;
  lastName: string | null;
  tenantId: string;
  groups: string[];
}

export interface EntraIdSSOResult {
  success: boolean;
  user?: EntraIdUserInfo;
  accessToken?: string;
  idToken?: string;
  error?: string;
}
```

### 2. Create Entra ID SSO Service

Create `electron/services/entraIdSsoService.ts`:

```typescript
import {
  ConfidentialClientApplication,
  Configuration,
  AuthorizationCodeRequest,
  CryptoProvider,
} from '@azure/msal-node';
import log from 'electron-log';
import { getTokenEncryptionService } from './tokenEncryptionService';
import type {
  EntraIdConfig,
  EntraIdTokenClaims,
  EntraIdUserInfo,
  EntraIdSSOResult,
} from '../types/entraId';

export class EntraIdSsoService {
  private cryptoProvider: CryptoProvider;

  constructor() {
    this.cryptoProvider = new CryptoProvider();
  }

  /**
   * Create MSAL client for a specific tenant
   */
  private createMsalClient(config: EntraIdConfig): ConfidentialClientApplication {
    const msalConfig: Configuration = {
      auth: {
        clientId: config.clientId,
        authority: `https://login.microsoftonline.com/${config.tenantId}`,
        clientSecret: config.clientSecret,
      },
      system: {
        loggerOptions: {
          loggerCallback: (level, message) => {
            log.debug(`MSAL [${level}]: ${message}`);
          },
        },
      },
    };

    return new ConfidentialClientApplication(msalConfig);
  }

  /**
   * Generate authorization URL for SSO login
   */
  async getAuthorizationUrl(config: EntraIdConfig, state: string): Promise<string> {
    const msalClient = this.createMsalClient(config);

    // Generate PKCE codes
    const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();

    // Store verifier for later use (you'll need to implement storage)
    // This could be in-memory cache or encrypted storage

    const authCodeUrlParams = {
      scopes: ['openid', 'profile', 'email', 'User.Read'],
      redirectUri: config.redirectUri,
      state,
      codeChallenge: challenge,
      codeChallengeMethod: 'S256' as const,
      prompt: 'select_account', // Allow account selection
    };

    const url = await msalClient.getAuthCodeUrl(authCodeUrlParams);
    return url;
  }

  /**
   * Exchange authorization code for tokens
   */
  async exchangeCodeForTokens(
    config: EntraIdConfig,
    code: string,
    codeVerifier: string
  ): Promise<EntraIdSSOResult> {
    try {
      const msalClient = this.createMsalClient(config);

      const tokenRequest: AuthorizationCodeRequest = {
        code,
        scopes: ['openid', 'profile', 'email', 'User.Read'],
        redirectUri: config.redirectUri,
        codeVerifier,
      };

      const response = await msalClient.acquireTokenByCode(tokenRequest);

      if (!response) {
        return { success: false, error: 'No token response received' };
      }

      // Parse ID token claims
      const claims = this.parseIdToken(response.idToken);

      // Verify tenant ID matches configuration
      if (claims.tid !== config.tenantId) {
        return {
          success: false,
          error: 'Token tenant ID does not match configured tenant',
        };
      }

      const user: EntraIdUserInfo = {
        id: claims.oid || claims.sub,
        email: claims.email || claims.preferred_username || '',
        displayName: claims.name || '',
        firstName: claims.given_name || null,
        lastName: claims.family_name || null,
        tenantId: claims.tid,
        groups: claims.groups || [],
      };

      return {
        success: true,
        user,
        accessToken: response.accessToken,
        idToken: response.idToken,
      };
    } catch (error) {
      log.error('Entra ID token exchange failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Token exchange failed',
      };
    }
  }

  /**
   * Verify user's email domain matches organization's verified domains
   */
  verifyEmailDomain(email: string, verifiedDomains: string[]): boolean {
    const emailDomain = email.split('@')[1]?.toLowerCase();
    return verifiedDomains.some(
      (domain) => domain.toLowerCase() === emailDomain
    );
  }

  /**
   * Test SSO configuration by attempting to get authorization URL
   */
  async testConfiguration(config: EntraIdConfig): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      // Try to generate an auth URL - this validates the configuration
      await this.getAuthorizationUrl(config, 'test-state');
      return { success: true };
    } catch (error) {
      log.error('Entra ID config test failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Configuration test failed',
      };
    }
  }

  /**
   * Get user info from Microsoft Graph API
   */
  async getUserInfoFromGraph(accessToken: string): Promise<EntraIdUserInfo | null> {
    try {
      const response = await fetch('https://graph.microsoft.com/v1.0/me', {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });

      if (!response.ok) {
        throw new Error(`Graph API error: ${response.status}`);
      }

      const data = await response.json();

      return {
        id: data.id,
        email: data.mail || data.userPrincipalName,
        displayName: data.displayName,
        firstName: data.givenName || null,
        lastName: data.surname || null,
        tenantId: '', // Not available from /me endpoint
        groups: [], // Would need separate call
      };
    } catch (error) {
      log.error('Failed to get user info from Graph:', error);
      return null;
    }
  }

  /**
   * Get user's group memberships from Microsoft Graph
   */
  async getUserGroups(accessToken: string): Promise<string[]> {
    try {
      const response = await fetch(
        'https://graph.microsoft.com/v1.0/me/memberOf',
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Graph API error: ${response.status}`);
      }

      const data = await response.json();
      return data.value
        .filter((item: any) => item['@odata.type'] === '#microsoft.graph.group')
        .map((group: any) => group.id);
    } catch (error) {
      log.error('Failed to get user groups from Graph:', error);
      return [];
    }
  }

  /**
   * Parse ID token to extract claims
   */
  private parseIdToken(idToken: string): EntraIdTokenClaims {
    const parts = idToken.split('.');
    if (parts.length !== 3) {
      throw new Error('Invalid ID token format');
    }

    const payload = Buffer.from(parts[1], 'base64').toString('utf-8');
    return JSON.parse(payload);
  }

  /**
   * Encrypt client secret for storage
   */
  async encryptClientSecret(clientSecret: string): Promise<string> {
    const encryptionService = getTokenEncryptionService();
    return encryptionService.encrypt(clientSecret);
  }

  /**
   * Decrypt client secret for use
   */
  async decryptClientSecret(encryptedSecret: string): Promise<string> {
    const encryptionService = getTokenEncryptionService();
    return encryptionService.decrypt(encryptedSecret);
  }
}

// Singleton
let entraIdSsoService: EntraIdSsoService | null = null;

export function getEntraIdSsoService(): EntraIdSsoService {
  if (!entraIdSsoService) {
    entraIdSsoService = new EntraIdSsoService();
  }
  return entraIdSsoService;
}
```

### 3. Entra ID Setup Instructions (for Admin UI)

Document the setup process for organization admins:

```markdown
## Setting Up Entra ID SSO

### Prerequisites
1. Azure AD Premium P1 or P2 license (for enterprise SSO features)
2. Global Administrator or Application Administrator role

### Steps

1. **Register Application in Azure Portal**
   - Go to Azure Portal > Azure Active Directory > App registrations
   - Click "New registration"
   - Name: "Magic Audit SSO"
   - Supported account types: "Accounts in this organizational directory only"
   - Redirect URI: `magicaudit://auth/callback` (or your configured redirect)

2. **Configure Authentication**
   - Go to Authentication
   - Add redirect URI if not added during registration
   - Enable "ID tokens" under Implicit grant

3. **Create Client Secret**
   - Go to Certificates & secrets
   - Click "New client secret"
   - Copy the secret value immediately (shown only once)

4. **Configure API Permissions**
   - Go to API permissions
   - Add permissions:
     - Microsoft Graph > Delegated > openid
     - Microsoft Graph > Delegated > profile
     - Microsoft Graph > Delegated > email
     - Microsoft Graph > Delegated > User.Read
   - Click "Grant admin consent"

5. **Configure Token Claims (Optional)**
   - Go to Token configuration
   - Add optional claims for groups if needed

6. **Get Configuration Values**
   - Application (client) ID: Found on Overview page
   - Directory (tenant) ID: Found on Overview page
   - Client secret: Created in step 3
```

## Files to Create

- `electron/types/entraId.ts`
- `electron/services/entraIdSsoService.ts`
- `electron/services/__tests__/entraIdSsoService.test.ts`
- `docs/sso-setup/entra-id-setup.md`

## Files to Modify

- None in this task (integration happens in EUM-010)

## Dos

- ✅ Use PKCE for authorization code flow
- ✅ Validate tenant ID in token matches configuration
- ✅ Encrypt client secrets before storage
- ✅ Log authentication events (without sensitive data)
- ✅ Handle token refresh if needed

## Don'ts

- ❌ Don't store client secrets in plain text
- ❌ Don't log tokens or secrets
- ❌ Don't skip tenant ID validation
- ❌ Don't hardcode any tenant-specific values

## Testing Instructions

1. Unit test token parsing
2. Unit test domain verification
3. Mock MSAL client for integration tests
4. Manual test with Entra ID test tenant
5. Test error handling for invalid configurations

## PR Preparation Checklist

Before completing, ensure:

- [ ] Service handles all Entra ID flows
- [ ] Client secrets are encrypted
- [ ] Setup documentation is clear
- [ ] Unit tests with >80% coverage
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Tests pass: `npm test`
- [ ] Created pull request with summary

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
