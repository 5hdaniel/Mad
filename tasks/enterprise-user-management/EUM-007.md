# EUM-007: Google Workspace SSO Service

## Task Info
- **Task ID:** EUM-007
- **Phase:** 2 - SSO Implementation
- **Dependencies:** EUM-005 (Phase 1 complete)
- **Can Start:** After Phase 1 merge
- **Parallel With:** EUM-006, EUM-008, EUM-009

## Goal

Extend the existing Google authentication to support enterprise SSO with Google Workspace, including domain-restricted login and hosted domain verification.

## Background

We already have `googleapis` integrated for individual Google OAuth login. This task extends that to support enterprise SSO where an organization uses Google Workspace for company-wide authentication.

## Deliverables

1. Google Workspace SSO service extending existing Google auth
2. Domain-restricted OIDC configuration
3. Hosted domain (hd) claim verification
4. Group membership via Directory API (optional)
5. Unit tests

## Technical Requirements

### 1. Create Google Workspace Types

Create `electron/types/googleWorkspace.ts`:

```typescript
export interface GoogleWorkspaceConfig {
  domain: string;          // e.g., "company.com"
  clientId: string;
  clientSecret: string;    // Will be encrypted
  redirectUri: string;
}

export interface GoogleIdTokenClaims {
  sub: string;             // User ID
  email: string;
  email_verified: boolean;
  name: string;
  given_name?: string;
  family_name?: string;
  picture?: string;
  hd?: string;             // Hosted domain (Google Workspace domain)
  locale?: string;
}

export interface GoogleWorkspaceUserInfo {
  id: string;
  email: string;
  displayName: string;
  firstName: string | null;
  lastName: string | null;
  avatarUrl: string | null;
  domain: string;
  emailVerified: boolean;
}

export interface GoogleWorkspaceSSOResult {
  success: boolean;
  user?: GoogleWorkspaceUserInfo;
  accessToken?: string;
  idToken?: string;
  refreshToken?: string;
  error?: string;
}
```

### 2. Create Google Workspace SSO Service

Create `electron/services/googleWorkspaceSsoService.ts`:

```typescript
import { google, Auth } from 'googleapis';
import log from 'electron-log';
import crypto from 'crypto';
import { getTokenEncryptionService } from './tokenEncryptionService';
import type {
  GoogleWorkspaceConfig,
  GoogleIdTokenClaims,
  GoogleWorkspaceUserInfo,
  GoogleWorkspaceSSOResult,
} from '../types/googleWorkspace';

export class GoogleWorkspaceSsoService {
  /**
   * Create OAuth2 client for a specific Workspace configuration
   */
  private createOAuth2Client(config: GoogleWorkspaceConfig): Auth.OAuth2Client {
    return new google.auth.OAuth2(
      config.clientId,
      config.clientSecret,
      config.redirectUri
    );
  }

  /**
   * Generate authorization URL for SSO login
   */
  getAuthorizationUrl(config: GoogleWorkspaceConfig, state: string): string {
    const oauth2Client = this.createOAuth2Client(config);

    // Generate PKCE code verifier and challenge
    const codeVerifier = crypto.randomBytes(32).toString('base64url');
    const codeChallenge = crypto
      .createHash('sha256')
      .update(codeVerifier)
      .digest('base64url');

    // Store code verifier for later use
    // (implementation needed - in-memory cache or encrypted storage)

    const url = oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: [
        'openid',
        'profile',
        'email',
      ],
      state,
      prompt: 'select_account',
      // Restrict to organization's domain
      hd: config.domain,
      // PKCE
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
    });

    return url;
  }

  /**
   * Exchange authorization code for tokens
   */
  async exchangeCodeForTokens(
    config: GoogleWorkspaceConfig,
    code: string,
    codeVerifier?: string
  ): Promise<GoogleWorkspaceSSOResult> {
    try {
      const oauth2Client = this.createOAuth2Client(config);

      const { tokens } = await oauth2Client.getToken({
        code,
        codeVerifier,
      });

      if (!tokens.id_token) {
        return { success: false, error: 'No ID token received' };
      }

      // Parse and verify ID token
      const claims = this.parseIdToken(tokens.id_token);

      // Verify hosted domain matches configuration
      if (!claims.hd || claims.hd.toLowerCase() !== config.domain.toLowerCase()) {
        return {
          success: false,
          error: `Email domain must be ${config.domain}`,
        };
      }

      // Verify email is verified
      if (!claims.email_verified) {
        return {
          success: false,
          error: 'Email address is not verified',
        };
      }

      const user: GoogleWorkspaceUserInfo = {
        id: claims.sub,
        email: claims.email,
        displayName: claims.name || claims.email,
        firstName: claims.given_name || null,
        lastName: claims.family_name || null,
        avatarUrl: claims.picture || null,
        domain: claims.hd,
        emailVerified: claims.email_verified,
      };

      return {
        success: true,
        user,
        accessToken: tokens.access_token || undefined,
        idToken: tokens.id_token,
        refreshToken: tokens.refresh_token || undefined,
      };
    } catch (error) {
      log.error('Google Workspace token exchange failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Token exchange failed',
      };
    }
  }

  /**
   * Verify user's email domain matches organization's domain
   */
  verifyEmailDomain(email: string, domain: string): boolean {
    const emailDomain = email.split('@')[1]?.toLowerCase();
    return emailDomain === domain.toLowerCase();
  }

  /**
   * Test SSO configuration
   */
  async testConfiguration(config: GoogleWorkspaceConfig): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      // Try to generate an auth URL - validates client ID at minimum
      this.getAuthorizationUrl(config, 'test-state');

      // For more thorough testing, we could try to fetch the OAuth2 discovery document
      const response = await fetch(
        'https://accounts.google.com/.well-known/openid-configuration'
      );

      if (!response.ok) {
        throw new Error('Failed to fetch Google OIDC configuration');
      }

      return { success: true };
    } catch (error) {
      log.error('Google Workspace config test failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Configuration test failed',
      };
    }
  }

  /**
   * Get user info from Google OAuth2 API
   */
  async getUserInfo(accessToken: string): Promise<GoogleWorkspaceUserInfo | null> {
    try {
      const response = await fetch(
        'https://www.googleapis.com/oauth2/v3/userinfo',
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Google API error: ${response.status}`);
      }

      const data = await response.json();

      return {
        id: data.sub,
        email: data.email,
        displayName: data.name,
        firstName: data.given_name || null,
        lastName: data.family_name || null,
        avatarUrl: data.picture || null,
        domain: data.hd || '',
        emailVerified: data.email_verified || false,
      };
    } catch (error) {
      log.error('Failed to get user info from Google:', error);
      return null;
    }
  }

  /**
   * Refresh access token
   */
  async refreshAccessToken(
    config: GoogleWorkspaceConfig,
    refreshToken: string
  ): Promise<{ accessToken: string; expiresAt: number } | null> {
    try {
      const oauth2Client = this.createOAuth2Client(config);
      oauth2Client.setCredentials({ refresh_token: refreshToken });

      const { credentials } = await oauth2Client.refreshAccessToken();

      if (!credentials.access_token) {
        return null;
      }

      return {
        accessToken: credentials.access_token,
        expiresAt: credentials.expiry_date || Date.now() + 3600000,
      };
    } catch (error) {
      log.error('Failed to refresh Google access token:', error);
      return null;
    }
  }

  /**
   * Parse ID token to extract claims
   */
  private parseIdToken(idToken: string): GoogleIdTokenClaims {
    const parts = idToken.split('.');
    if (parts.length !== 3) {
      throw new Error('Invalid ID token format');
    }

    const payload = Buffer.from(parts[1], 'base64').toString('utf-8');
    return JSON.parse(payload);
  }

  /**
   * Encrypt client secret for storage
   */
  async encryptClientSecret(clientSecret: string): Promise<string> {
    const encryptionService = getTokenEncryptionService();
    return encryptionService.encrypt(clientSecret);
  }

  /**
   * Decrypt client secret for use
   */
  async decryptClientSecret(encryptedSecret: string): Promise<string> {
    const encryptionService = getTokenEncryptionService();
    return encryptionService.decrypt(encryptedSecret);
  }
}

// Singleton
let googleWorkspaceSsoService: GoogleWorkspaceSsoService | null = null;

export function getGoogleWorkspaceSsoService(): GoogleWorkspaceSsoService {
  if (!googleWorkspaceSsoService) {
    googleWorkspaceSsoService = new GoogleWorkspaceSsoService();
  }
  return googleWorkspaceSsoService;
}
```

### 3. Google Workspace Setup Instructions

```markdown
## Setting Up Google Workspace SSO

### Prerequisites
1. Google Workspace admin access
2. Domain verified in Google Workspace

### Steps

1. **Create OAuth Credentials in Google Cloud Console**
   - Go to Google Cloud Console > APIs & Services > Credentials
   - Click "Create Credentials" > "OAuth client ID"
   - Application type: "Desktop app" or "Web application"
   - Name: "Magic Audit SSO"
   - Add authorized redirect URI: `magicaudit://auth/callback`

2. **Configure OAuth Consent Screen**
   - Go to OAuth consent screen
   - User type: "Internal" (for Workspace domain only)
   - Fill in app name, user support email, developer contact
   - Add scopes: email, profile, openid

3. **Get Configuration Values**
   - Client ID: Shown after creating credentials
   - Client Secret: Shown after creating credentials
   - Domain: Your Google Workspace domain (e.g., company.com)

4. **Verify Domain (Important)**
   - The `hd` parameter restricts login to your domain
   - Only users with @yourdomain.com can authenticate
```

## Files to Create

- `electron/types/googleWorkspace.ts`
- `electron/services/googleWorkspaceSsoService.ts`
- `electron/services/__tests__/googleWorkspaceSsoService.test.ts`
- `docs/sso-setup/google-workspace-setup.md`

## Files to Modify

- None in this task (integration happens in EUM-010)

## Dos

- ✅ Use PKCE for authorization code flow
- ✅ Validate hosted domain (hd) claim
- ✅ Verify email_verified claim
- ✅ Encrypt client secrets before storage
- ✅ Handle token refresh

## Don'ts

- ❌ Don't store client secrets in plain text
- ❌ Don't log tokens or secrets
- ❌ Don't skip domain verification
- ❌ Don't accept unverified emails

## Testing Instructions

1. Unit test token parsing
2. Unit test domain verification
3. Mock googleapis client for tests
4. Manual test with Google Workspace test domain
5. Test error handling for wrong domain

## PR Preparation Checklist

Before completing, ensure:

- [ ] Service handles all Google Workspace flows
- [ ] Client secrets are encrypted
- [ ] Domain verification works
- [ ] Setup documentation is clear
- [ ] Unit tests with >80% coverage
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Tests pass: `npm test`
- [ ] Created pull request with summary

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
