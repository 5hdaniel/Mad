# EUM-002: Organization Service

## Task Info
- **Task ID:** EUM-002
- **Phase:** 1 - Foundation
- **Dependencies:** None (can work with mock data until EUM-001 is merged)
- **Can Start:** Immediately
- **Parallel With:** EUM-001, EUM-003, EUM-004

## Goal

Create a TypeScript service for managing organizations and their members, including CRUD operations, membership management, and seat tracking.

## Non-Goals

- ❌ Creating database schema (handled in EUM-001)
- ❌ Building UI components
- ❌ Implementing SSO logic (handled in Phase 2)
- ❌ Implementing SCIM provisioning (handled in Phase 4)
- ❌ Modifying existing user service
- ❌ Adding billing/payment logic

## Background

This service will be the core business logic layer for organization management. It communicates with Supabase for data persistence and will be called by IPC handlers.

## Deliverables

1. Organization service with full CRUD operations
2. Membership management functions
3. TypeScript types for organizations
4. IPC handlers for renderer communication
5. Unit tests with >80% coverage

## Acceptance Criteria

- [ ] `createOrganization()` creates org and adds creator as owner
- [ ] `getOrganization()` returns null for non-existent/deleted orgs
- [ ] `getOrganizationsForUser()` returns only orgs where user is active member
- [ ] `inviteMember()` respects seat limits and prevents duplicates
- [ ] `removeMember()` prevents removing last owner
- [ ] `updateMemberRole()` prevents changing owner role directly
- [ ] `transferOwnership()` atomically swaps owner role
- [ ] All methods log errors using electron-log
- [ ] All IPC handlers return `{ success, data?, error? }` format
- [ ] Unit tests cover all public methods with >80% coverage

## Technical Requirements

### 1. Create Organization Types

Create `electron/types/organization.ts`:

```typescript
export interface Organization {
  id: string;
  name: string;
  slug: string;
  logoUrl: string | null;

  // SSO
  ssoEnabled: boolean;
  ssoProvider: 'entra_id' | 'google_workspace' | null;
  ssoEnforced: boolean;

  // SCIM
  scimEnabled: boolean;

  // License
  licenseType: 'team' | 'enterprise';
  licenseSeats: number;
  seatsUsed: number;

  // Domains
  verifiedDomains: string[];

  // Metadata
  createdAt: string;
  updatedAt: string;
  createdBy: string | null;
}

export interface OrganizationMember {
  id: string;
  organizationId: string;
  userId: string;
  role: 'owner' | 'admin' | 'member';
  status: 'active' | 'suspended' | 'pending';
  provisionedBy: 'manual' | 'scim' | 'sso_jit';
  provisionedAt: string;

  // For pending invitations
  invitedEmail: string | null;
  invitedAt: string | null;
  invitedBy: string | null;

  // Joined user info (populated from users table)
  user?: {
    id: string;
    email: string;
    displayName: string | null;
    avatarUrl: string | null;
  };

  createdAt: string;
  updatedAt: string;
}

export interface CreateOrganizationInput {
  name: string;
  slug: string;
  licenseType: 'team' | 'enterprise';
  licenseSeats: number;
  createdBy: string;
}

export interface UpdateOrganizationInput {
  name?: string;
  slug?: string;
  logoUrl?: string | null;
  ssoEnforced?: boolean;
  verifiedDomains?: string[];
}

export interface InviteMemberInput {
  organizationId: string;
  email: string;
  role: 'admin' | 'member';
  invitedBy: string;
}

export interface OrganizationFilters {
  userId?: string;
  includeDeleted?: boolean;
}

export interface MemberFilters {
  status?: 'active' | 'suspended' | 'pending';
  role?: 'owner' | 'admin' | 'member';
  search?: string;
}
```

### 2. Create Organization Service

Create `electron/services/organizationService.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import log from 'electron-log';
import type {
  Organization,
  OrganizationMember,
  CreateOrganizationInput,
  UpdateOrganizationInput,
  InviteMemberInput,
  OrganizationFilters,
  MemberFilters,
} from '../types/organization';

export class OrganizationService {
  private supabase;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  // ==================== Organization CRUD ====================

  async createOrganization(input: CreateOrganizationInput): Promise<Organization> {
    // 1. Validate slug is unique
    // 2. Create organization
    // 3. Add creator as owner
    // 4. Return created org
  }

  async getOrganization(orgId: string): Promise<Organization | null> {
    // Get org by ID, excluding soft-deleted
  }

  async getOrganizationBySlug(slug: string): Promise<Organization | null> {
    // Get org by slug for SSO lookup
  }

  async getOrganizationsForUser(userId: string): Promise<Organization[]> {
    // Get all orgs where user is an active member
  }

  async updateOrganization(orgId: string, input: UpdateOrganizationInput): Promise<Organization> {
    // Update org fields
  }

  async deleteOrganization(orgId: string): Promise<void> {
    // Soft delete - set deleted_at
  }

  // ==================== Membership Management ====================

  async getMembers(orgId: string, filters?: MemberFilters): Promise<OrganizationMember[]> {
    // Get all members with optional filtering
    // Join with users table to get user details
  }

  async getMember(orgId: string, userId: string): Promise<OrganizationMember | null> {
    // Get specific member
  }

  async inviteMember(input: InviteMemberInput): Promise<OrganizationMember> {
    // 1. Check seat availability
    // 2. Check if user already exists
    // 3. If exists: add as member
    // 4. If not: create pending invitation
    // 5. Return member record
  }

  async removeMember(orgId: string, userId: string): Promise<void> {
    // 1. Check not removing last owner
    // 2. Remove member record
    // 3. Seats count will auto-update via trigger
  }

  async updateMemberRole(
    orgId: string,
    userId: string,
    newRole: 'admin' | 'member'
  ): Promise<OrganizationMember> {
    // Update member role (can't change owner this way)
  }

  async suspendMember(orgId: string, userId: string): Promise<void> {
    // Set status to suspended
  }

  async reactivateMember(orgId: string, userId: string): Promise<void> {
    // Set status back to active
  }

  async transferOwnership(
    orgId: string,
    fromUserId: string,
    toUserId: string
  ): Promise<void> {
    // 1. Verify fromUser is owner
    // 2. Verify toUser is active member
    // 3. Update roles in transaction
  }

  // ==================== Seat Management ====================

  async checkSeatAvailability(orgId: string): Promise<{
    available: boolean;
    seatsUsed: number;
    seatsTotal: number;
  }> {
    // Check if org has available seats
  }

  async getSeatsInfo(orgId: string): Promise<{
    used: number;
    total: number;
    available: number;
  }> {
    // Get seat usage info
  }

  // ==================== Domain Management ====================

  async addDomain(orgId: string, domain: string): Promise<void> {
    // Add domain to verified_domains array
  }

  async removeDomain(orgId: string, domain: string): Promise<void> {
    // Remove domain from verified_domains array
  }

  async verifyDomainOwnership(orgId: string, domain: string): Promise<boolean> {
    // Domain verification logic (DNS TXT record check)
    // For now, can be a placeholder that returns true
  }

  // ==================== Helpers ====================

  async isUserInOrg(userId: string, orgId: string): Promise<boolean> {
    // Check if user is active member of org
  }

  async getUserRole(userId: string, orgId: string): Promise<string | null> {
    // Get user's role in org
  }

  async generateUniqueSlug(name: string): Promise<string> {
    // Generate URL-safe slug from name
    // Check for uniqueness, append number if needed
  }

  private mapToOrganization(row: any): Organization {
    // Map database row to Organization type
  }

  private mapToMember(row: any): OrganizationMember {
    // Map database row to OrganizationMember type
  }
}

// Singleton instance
let organizationService: OrganizationService | null = null;

export function getOrganizationService(): OrganizationService {
  if (!organizationService) {
    organizationService = new OrganizationService(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    );
  }
  return organizationService;
}
```

### 3. Create IPC Handlers

Create `electron/handlers/organizationHandlers.ts`:

```typescript
import { ipcMain } from 'electron';
import { getOrganizationService } from '../services/organizationService';
import { getAuditService } from '../services/auditService'; // from EUM-003
import log from 'electron-log';

export function registerOrganizationHandlers(): void {
  const orgService = getOrganizationService();

  // Organization CRUD
  ipcMain.handle('org:create', async (_, input) => {
    try {
      const org = await orgService.createOrganization(input);
      // Log audit event
      return { success: true, data: org };
    } catch (error) {
      log.error('Failed to create organization:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:get', async (_, orgId) => {
    try {
      const org = await orgService.getOrganization(orgId);
      return { success: true, data: org };
    } catch (error) {
      log.error('Failed to get organization:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:get-by-slug', async (_, slug) => {
    try {
      const org = await orgService.getOrganizationBySlug(slug);
      return { success: true, data: org };
    } catch (error) {
      log.error('Failed to get organization by slug:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:get-for-user', async (_, userId) => {
    try {
      const orgs = await orgService.getOrganizationsForUser(userId);
      return { success: true, data: orgs };
    } catch (error) {
      log.error('Failed to get organizations for user:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:update', async (_, orgId, input) => {
    try {
      const org = await orgService.updateOrganization(orgId, input);
      return { success: true, data: org };
    } catch (error) {
      log.error('Failed to update organization:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:delete', async (_, orgId) => {
    try {
      await orgService.deleteOrganization(orgId);
      return { success: true };
    } catch (error) {
      log.error('Failed to delete organization:', error);
      return { success: false, error: error.message };
    }
  });

  // Member Management
  ipcMain.handle('org:get-members', async (_, orgId, filters) => {
    try {
      const members = await orgService.getMembers(orgId, filters);
      return { success: true, data: members };
    } catch (error) {
      log.error('Failed to get members:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:invite-member', async (_, input) => {
    try {
      const member = await orgService.inviteMember(input);
      return { success: true, data: member };
    } catch (error) {
      log.error('Failed to invite member:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:remove-member', async (_, orgId, userId) => {
    try {
      await orgService.removeMember(orgId, userId);
      return { success: true };
    } catch (error) {
      log.error('Failed to remove member:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:update-member-role', async (_, orgId, userId, newRole) => {
    try {
      const member = await orgService.updateMemberRole(orgId, userId, newRole);
      return { success: true, data: member };
    } catch (error) {
      log.error('Failed to update member role:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:suspend-member', async (_, orgId, userId) => {
    try {
      await orgService.suspendMember(orgId, userId);
      return { success: true };
    } catch (error) {
      log.error('Failed to suspend member:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:reactivate-member', async (_, orgId, userId) => {
    try {
      await orgService.reactivateMember(orgId, userId);
      return { success: true };
    } catch (error) {
      log.error('Failed to reactivate member:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:transfer-ownership', async (_, orgId, fromUserId, toUserId) => {
    try {
      await orgService.transferOwnership(orgId, fromUserId, toUserId);
      return { success: true };
    } catch (error) {
      log.error('Failed to transfer ownership:', error);
      return { success: false, error: error.message };
    }
  });

  // Seat Management
  ipcMain.handle('org:check-seats', async (_, orgId) => {
    try {
      const result = await orgService.checkSeatAvailability(orgId);
      return { success: true, data: result };
    } catch (error) {
      log.error('Failed to check seats:', error);
      return { success: false, error: error.message };
    }
  });

  // Domain Management
  ipcMain.handle('org:add-domain', async (_, orgId, domain) => {
    try {
      await orgService.addDomain(orgId, domain);
      return { success: true };
    } catch (error) {
      log.error('Failed to add domain:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('org:remove-domain', async (_, orgId, domain) => {
    try {
      await orgService.removeDomain(orgId, domain);
      return { success: true };
    } catch (error) {
      log.error('Failed to remove domain:', error);
      return { success: false, error: error.message };
    }
  });
}
```

### 4. Update Preload Script

Add to `electron/preload.ts`:

```typescript
org: {
  // Organization CRUD
  create: (input: CreateOrganizationInput) => ipcRenderer.invoke('org:create', input),
  get: (orgId: string) => ipcRenderer.invoke('org:get', orgId),
  getBySlug: (slug: string) => ipcRenderer.invoke('org:get-by-slug', slug),
  getForUser: (userId: string) => ipcRenderer.invoke('org:get-for-user', userId),
  update: (orgId: string, input: UpdateOrganizationInput) =>
    ipcRenderer.invoke('org:update', orgId, input),
  delete: (orgId: string) => ipcRenderer.invoke('org:delete', orgId),

  // Members
  getMembers: (orgId: string, filters?: MemberFilters) =>
    ipcRenderer.invoke('org:get-members', orgId, filters),
  inviteMember: (input: InviteMemberInput) =>
    ipcRenderer.invoke('org:invite-member', input),
  removeMember: (orgId: string, userId: string) =>
    ipcRenderer.invoke('org:remove-member', orgId, userId),
  updateMemberRole: (orgId: string, userId: string, role: string) =>
    ipcRenderer.invoke('org:update-member-role', orgId, userId, role),
  suspendMember: (orgId: string, userId: string) =>
    ipcRenderer.invoke('org:suspend-member', orgId, userId),
  reactivateMember: (orgId: string, userId: string) =>
    ipcRenderer.invoke('org:reactivate-member', orgId, userId),
  transferOwnership: (orgId: string, fromUserId: string, toUserId: string) =>
    ipcRenderer.invoke('org:transfer-ownership', orgId, fromUserId, toUserId),

  // Seats
  checkSeats: (orgId: string) => ipcRenderer.invoke('org:check-seats', orgId),

  // Domains
  addDomain: (orgId: string, domain: string) =>
    ipcRenderer.invoke('org:add-domain', orgId, domain),
  removeDomain: (orgId: string, domain: string) =>
    ipcRenderer.invoke('org:remove-domain', orgId, domain),
},
```

## Files to Create

- `electron/types/organization.ts`
- `electron/services/organizationService.ts`
- `electron/handlers/organizationHandlers.ts`
- `electron/services/__tests__/organizationService.test.ts`

## Files to Modify

- `electron/preload.ts` - Add organization API
- `electron/main.ts` - Register organization handlers
- `src/types/electron.d.ts` - Add organization types

## When to Stop and Ask

You MUST stop and ask the PM if:

1. **Database schema mismatch** - If the schema from EUM-001 has columns or types that don't match what's expected in this service
2. **Existing service conflicts** - If there's already an organization or user management service that would conflict
3. **Supabase client pattern** - If you're unsure how to initialize the Supabase client consistently with other services
4. **Transaction support** - If Supabase transactions work differently than expected for multi-step operations
5. **Error handling patterns** - If existing services use different error handling patterns than specified here
6. **Audit logging integration** - If you're unsure how to call the audit service from EUM-003

Do NOT guess or make assumptions. Ask first.

## Integration Notes

### For EUM-001 (Database Schema)
- This service depends on the `organizations` and `organization_members` tables
- Expect snake_case columns from database, map to camelCase in TypeScript
- `seats_used` is auto-updated by trigger, don't update manually

### For EUM-003 (Audit Service)
- Call audit service after successful organization/member operations
- Pass actor context (userId, email) from IPC handler context
- Use predefined action types from EUM-003

### For EUM-004 (RBAC Service)
- Organization handlers should check permissions before operations
- Use `requirePermission()` pattern for protected operations
- Owner transfer requires `PERMISSIONS.OWNERSHIP_TRANSFER`

### For EUM-005 (Integration Task)
- Service must be a singleton (use `getOrganizationService()`)
- All IPC handlers must return `{ success, data?, error? }` format
- Export types from `electron/types/organization.ts`

## Dos

- ✅ Use TypeScript strict mode
- ✅ Handle all error cases with proper error messages
- ✅ Log all operations using electron-log
- ✅ Use transactions for multi-step operations
- ✅ Validate inputs before database operations
- ✅ Write comprehensive unit tests

## Don'ts

- ❌ Don't expose Supabase client directly to renderer
- ❌ Don't allow removing the last owner
- ❌ Don't allow exceeding seat limits
- ❌ Don't store sensitive data in logs

## Testing Instructions

1. Unit test all service methods with mocked Supabase
2. Test edge cases: duplicate slugs, seat limits, last owner removal
3. Test error handling for all failure modes
4. Integration test with local Supabase (after EUM-001)

## PR Preparation Checklist

Before completing, ensure:

- [ ] TypeScript strict mode compliance
- [ ] All methods have proper error handling
- [ ] Unit tests with >80% coverage
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Tests pass: `npm test`
- [ ] Created pull request with summary

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
