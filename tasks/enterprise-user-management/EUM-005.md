# EUM-005: Phase 1 Integration & Testing

## Task Info
- **Task ID:** EUM-005
- **Phase:** 1 - Foundation (MERGE TASK)
- **Dependencies:** EUM-001, EUM-002, EUM-003, EUM-004
- **Can Start:** After all Phase 1 parallel tasks are complete
- **Blocks:** All Phase 2 tasks

## Goal

Integrate all Phase 1 foundation services, register IPC handlers, update the preload bridge, verify everything works together, and write integration tests.

## Background

This is the merge task for Phase 1. It combines the work from EUM-001 (schema), EUM-002 (organization service), EUM-003 (audit service), and EUM-004 (RBAC service) into a working foundation.

## Non-Goals

- ❌ Adding new services beyond EUM-001 through EUM-004
- ❌ Building UI components (handled in Phase 3)
- ❌ Implementing SSO (handled in Phase 2)
- ❌ Performance optimization beyond basic verification
- ❌ Production deployment configuration
- ❌ Seed data creation (optional, not required)

## Deliverables

1. All services registered and working together
2. IPC handlers registered in main process
3. Preload bridge updated with all new APIs
4. TypeScript types exported for renderer
5. Integration tests verifying services work together
6. RLS policies verified
7. Documentation updated

## Technical Requirements

### 1. Register All Handlers in Main Process

Update `electron/main.ts`:

```typescript
import { registerOrganizationHandlers } from './handlers/organizationHandlers';
import { registerAuditHandlers } from './handlers/auditHandlers';
import { registerRBACHandlers } from './handlers/rbacHandlers';

// In your app.whenReady() or initialization code:
function registerAllHandlers(): void {
  // Existing handlers...

  // Enterprise User Management - Phase 1
  registerOrganizationHandlers();
  registerAuditHandlers();
  registerRBACHandlers();
}
```

### 2. Update Preload Script

Ensure `electron/preload.ts` exports all APIs:

```typescript
import { contextBridge, ipcRenderer } from 'electron';

// ... existing imports and types ...

// Import new types
import type {
  Organization,
  OrganizationMember,
  CreateOrganizationInput,
  UpdateOrganizationInput,
  InviteMemberInput,
  MemberFilters,
} from './types/organization';

import type {
  AuditLogEntry,
  AuditLogFilters,
  AuditLogPagination,
  PaginatedAuditLogs,
} from './types/audit';

import type {
  Role,
  Permission,
  PermissionCheckResult,
} from './types/rbac';

contextBridge.exposeInMainWorld('api', {
  // ... existing APIs ...

  // Organization API
  org: {
    create: (input: CreateOrganizationInput) => ipcRenderer.invoke('org:create', input),
    get: (orgId: string) => ipcRenderer.invoke('org:get', orgId),
    getBySlug: (slug: string) => ipcRenderer.invoke('org:get-by-slug', slug),
    getForUser: (userId: string) => ipcRenderer.invoke('org:get-for-user', userId),
    update: (orgId: string, input: UpdateOrganizationInput) =>
      ipcRenderer.invoke('org:update', orgId, input),
    delete: (orgId: string) => ipcRenderer.invoke('org:delete', orgId),
    getMembers: (orgId: string, filters?: MemberFilters) =>
      ipcRenderer.invoke('org:get-members', orgId, filters),
    inviteMember: (input: InviteMemberInput) =>
      ipcRenderer.invoke('org:invite-member', input),
    removeMember: (orgId: string, userId: string) =>
      ipcRenderer.invoke('org:remove-member', orgId, userId),
    updateMemberRole: (orgId: string, userId: string, role: string) =>
      ipcRenderer.invoke('org:update-member-role', orgId, userId, role),
    suspendMember: (orgId: string, userId: string) =>
      ipcRenderer.invoke('org:suspend-member', orgId, userId),
    reactivateMember: (orgId: string, userId: string) =>
      ipcRenderer.invoke('org:reactivate-member', orgId, userId),
    transferOwnership: (orgId: string, fromUserId: string, toUserId: string) =>
      ipcRenderer.invoke('org:transfer-ownership', orgId, fromUserId, toUserId),
    checkSeats: (orgId: string) => ipcRenderer.invoke('org:check-seats', orgId),
    addDomain: (orgId: string, domain: string) =>
      ipcRenderer.invoke('org:add-domain', orgId, domain),
    removeDomain: (orgId: string, domain: string) =>
      ipcRenderer.invoke('org:remove-domain', orgId, domain),
  },

  // Audit API
  audit: {
    getLogs: (orgId: string, filters?: AuditLogFilters, pagination?: AuditLogPagination) =>
      ipcRenderer.invoke('audit:get-logs', orgId, filters, pagination),
    getLogsForResource: (orgId: string, resourceType: string, resourceId: string, pagination?: AuditLogPagination) =>
      ipcRenderer.invoke('audit:get-logs-for-resource', orgId, resourceType, resourceId, pagination),
    export: (orgId: string, filters?: AuditLogFilters) =>
      ipcRenderer.invoke('audit:export', orgId, filters),
    getStats: (orgId: string, startDate?: string, endDate?: string) =>
      ipcRenderer.invoke('audit:get-stats', orgId, startDate, endDate),
  },

  // RBAC API
  rbac: {
    getRole: (userId: string, orgId: string) =>
      ipcRenderer.invoke('rbac:get-role', userId, orgId),
    hasPermission: (userId: string, orgId: string, permission: string) =>
      ipcRenderer.invoke('rbac:has-permission', userId, orgId, permission),
    getPermissions: (userId: string, orgId: string) =>
      ipcRenderer.invoke('rbac:get-permissions', userId, orgId),
    isAdminOrOwner: (userId: string, orgId: string) =>
      ipcRenderer.invoke('rbac:is-admin-or-owner', userId, orgId),
    canManageUser: (actorId: string, targetUserId: string, orgId: string) =>
      ipcRenderer.invoke('rbac:can-manage-user', actorId, targetUserId, orgId),
  },
});
```

### 3. Update TypeScript Definitions for Renderer

Update `src/types/electron.d.ts`:

```typescript
// Add these type definitions for the renderer process

interface OrganizationAPI {
  create(input: CreateOrganizationInput): Promise<APIResponse<Organization>>;
  get(orgId: string): Promise<APIResponse<Organization | null>>;
  getBySlug(slug: string): Promise<APIResponse<Organization | null>>;
  getForUser(userId: string): Promise<APIResponse<Organization[]>>;
  update(orgId: string, input: UpdateOrganizationInput): Promise<APIResponse<Organization>>;
  delete(orgId: string): Promise<APIResponse<void>>;
  getMembers(orgId: string, filters?: MemberFilters): Promise<APIResponse<OrganizationMember[]>>;
  inviteMember(input: InviteMemberInput): Promise<APIResponse<OrganizationMember>>;
  removeMember(orgId: string, userId: string): Promise<APIResponse<void>>;
  updateMemberRole(orgId: string, userId: string, role: string): Promise<APIResponse<OrganizationMember>>;
  suspendMember(orgId: string, userId: string): Promise<APIResponse<void>>;
  reactivateMember(orgId: string, userId: string): Promise<APIResponse<void>>;
  transferOwnership(orgId: string, fromUserId: string, toUserId: string): Promise<APIResponse<void>>;
  checkSeats(orgId: string): Promise<APIResponse<SeatsInfo>>;
  addDomain(orgId: string, domain: string): Promise<APIResponse<void>>;
  removeDomain(orgId: string, domain: string): Promise<APIResponse<void>>;
}

interface AuditAPI {
  getLogs(orgId: string, filters?: AuditLogFilters, pagination?: AuditLogPagination): Promise<APIResponse<PaginatedAuditLogs>>;
  getLogsForResource(orgId: string, resourceType: string, resourceId: string, pagination?: AuditLogPagination): Promise<APIResponse<PaginatedAuditLogs>>;
  export(orgId: string, filters?: AuditLogFilters): Promise<APIResponse<string>>;
  getStats(orgId: string, startDate?: string, endDate?: string): Promise<APIResponse<AuditStats>>;
}

interface RBACAPI {
  getRole(userId: string, orgId: string): Promise<APIResponse<Role | null>>;
  hasPermission(userId: string, orgId: string, permission: string): Promise<APIResponse<PermissionCheckResult>>;
  getPermissions(userId: string, orgId: string): Promise<APIResponse<Permission[]>>;
  isAdminOrOwner(userId: string, orgId: string): Promise<APIResponse<boolean>>;
  canManageUser(actorId: string, targetUserId: string, orgId: string): Promise<APIResponse<PermissionCheckResult>>;
}

declare global {
  interface Window {
    api: {
      // ... existing APIs ...
      org: OrganizationAPI;
      audit: AuditAPI;
      rbac: RBACAPI;
    };
  }
}
```

### 4. Integration Tests

Create `electron/services/__tests__/integration/phase1.integration.test.ts`:

```typescript
import { OrganizationService } from '../../organizationService';
import { AuditService } from '../../auditService';
import { RBACService } from '../../rbacService';
import { AUDIT_ACTIONS, PERMISSIONS, ROLES } from '../../../types';

// These tests require a test Supabase instance
describe('Phase 1 Integration Tests', () => {
  let orgService: OrganizationService;
  let auditService: AuditService;
  let rbacService: RBACService;

  let testOrgId: string;
  let testOwnerId: string;
  let testAdminId: string;
  let testMemberId: string;

  beforeAll(async () => {
    // Initialize services with test Supabase
    orgService = new OrganizationService(
      process.env.TEST_SUPABASE_URL!,
      process.env.TEST_SUPABASE_KEY!
    );
    auditService = new AuditService(
      process.env.TEST_SUPABASE_URL!,
      process.env.TEST_SUPABASE_KEY!
    );
    rbacService = new RBACService(
      process.env.TEST_SUPABASE_URL!,
      process.env.TEST_SUPABASE_KEY!
    );
  });

  describe('Organization Lifecycle', () => {
    test('create organization and verify owner role', async () => {
      // Create org
      const org = await orgService.createOrganization({
        name: 'Test Organization',
        slug: 'test-org-' + Date.now(),
        licenseType: 'team',
        licenseSeats: 10,
        createdBy: testOwnerId,
      });

      testOrgId = org.id;

      // Verify owner role
      const role = await rbacService.getUserRole(testOwnerId, testOrgId);
      expect(role).toBe(ROLES.OWNER);

      // Verify owner permissions
      const permissions = await rbacService.getUserPermissions(testOwnerId, testOrgId);
      expect(permissions).toContain(PERMISSIONS.ORG_DELETE);
      expect(permissions).toContain(PERMISSIONS.OWNERSHIP_TRANSFER);
    });

    test('invite member and verify audit log', async () => {
      // Invite member
      const member = await orgService.inviteMember({
        organizationId: testOrgId,
        email: 'member@test.com',
        role: 'member',
        invitedBy: testOwnerId,
      });

      // Verify member role
      const role = await rbacService.getUserRole(member.userId, testOrgId);
      expect(role).toBe(ROLES.MEMBER);

      // Verify audit log was created
      const logs = await auditService.getLogs(testOrgId, {
        action: AUDIT_ACTIONS.USER_INVITED,
      });
      expect(logs.logs.length).toBeGreaterThan(0);
      expect(logs.logs[0].action).toBe(AUDIT_ACTIONS.USER_INVITED);
    });

    test('RBAC prevents member from inviting users', async () => {
      const result = await rbacService.hasPermission(
        testMemberId,
        testOrgId,
        PERMISSIONS.MEMBERS_INVITE
      );

      expect(result.allowed).toBe(false);
    });

    test('admin can manage members but not owners', async () => {
      // Admin can manage member
      const canManageMember = await rbacService.canManageUser(
        testAdminId,
        testMemberId,
        testOrgId
      );
      expect(canManageMember.allowed).toBe(true);

      // Admin cannot manage owner
      const canManageOwner = await rbacService.canManageUser(
        testAdminId,
        testOwnerId,
        testOrgId
      );
      expect(canManageOwner.allowed).toBe(false);
    });
  });

  describe('Seat Management', () => {
    test('respects seat limits', async () => {
      // Fill seats to limit
      // Try to add one more
      // Verify error
    });
  });

  describe('Audit Export', () => {
    test('exports audit logs to CSV', async () => {
      const csv = await auditService.exportLogs(testOrgId);

      expect(csv).toContain('Timestamp');
      expect(csv).toContain('Action');
      expect(csv).toContain(AUDIT_ACTIONS.USER_INVITED);
    });
  });

  afterAll(async () => {
    // Cleanup test data
    if (testOrgId) {
      await orgService.deleteOrganization(testOrgId);
    }
  });
});
```

### 5. Verify RLS Policies

Create a test script to verify RLS policies work correctly:

```typescript
// scripts/verify-rls.ts
import { createClient } from '@supabase/supabase-js';

async function verifyRLS() {
  // Test as User A (member of Org 1)
  const userAClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    // Set auth context for User A
  });

  // Try to access Org 2 (should fail)
  const { data, error } = await userAClient
    .from('organizations')
    .select('*')
    .eq('id', 'org-2-id');

  if (data && data.length > 0) {
    throw new Error('RLS FAILED: User A can see Org 2!');
  }

  console.log('✓ RLS policies working correctly');
}
```

## Verification Checklist

### Database
- [ ] All migrations applied successfully
- [ ] Tables created with correct schema
- [ ] Indexes created
- [ ] RLS enabled on all tables
- [ ] RLS policies working (verified with test script)
- [ ] Triggers working (updated_at, seats_used)

### Services
- [ ] OrganizationService all methods working
- [ ] AuditService all methods working
- [ ] RBACService all methods working
- [ ] Services can communicate with each other
- [ ] Error handling consistent across services

### IPC
- [ ] All handlers registered
- [ ] Preload bridge exports all APIs
- [ ] TypeScript types available in renderer
- [ ] All IPC calls return proper response format

### Tests
- [ ] Unit tests passing for all services
- [ ] Integration tests passing
- [ ] Coverage > 80%
- [ ] RLS verification script passing

## Files to Modify

- `electron/main.ts` - Register all handlers
- `electron/preload.ts` - Export all APIs
- `src/types/electron.d.ts` - Add TypeScript definitions

## Files to Create

- `electron/services/__tests__/integration/phase1.integration.test.ts`
- `scripts/verify-rls.ts`

## Acceptance Criteria

- [ ] All Phase 1 task branches merged without conflicts
- [ ] All handlers registered in `electron/main.ts`
- [ ] All APIs exposed via `electron/preload.ts`
- [ ] All TypeScript types available in `src/types/electron.d.ts`
- [ ] Migration applies successfully to clean Supabase instance
- [ ] RLS policies verified with test script
- [ ] All triggers working (updated_at, seats_used)
- [ ] Unit tests passing for all services (>80% coverage)
- [ ] Integration tests passing
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Services can call each other (org -> audit, handlers -> RBAC)
- [ ] All IPC round-trips work from renderer to main and back

## When to Stop and Ask

You MUST stop and ask the PM if:

1. **Merge conflicts** - If Phase 1 branches have significant conflicts that require design decisions
2. **Breaking changes** - If integrating services requires changes to individual service implementations
3. **RLS failures** - If RLS verification reveals cross-tenant data access issues
4. **Type conflicts** - If TypeScript types from different tasks are incompatible
5. **Test failures** - If integration tests fail due to design issues (not just bugs)
6. **Missing dependencies** - If services expect functionality not delivered by other Phase 1 tasks

Do NOT guess or make assumptions. Ask first.

## Integration Notes

### This Task Depends On
- **EUM-001**: Database schema must be applied first
- **EUM-002**: Organization service must be completed
- **EUM-003**: Audit service must be completed
- **EUM-004**: RBAC service must be completed

### This Task Blocks
- **All Phase 2 tasks**: SSO implementation depends on Phase 1 foundation
- Phase 2 cannot start until this task is complete and merged

### Integration Points to Verify
1. OrganizationService can insert into `organizations` and `organization_members` tables
2. AuditService can insert into `audit_logs` table
3. RBACService can query `organization_members` for role checks
4. Organization handlers call audit service after operations
5. Handlers use RBAC service for permission checks
6. Preload bridge correctly marshals data between main and renderer

### Concurrency Considerations
- Multiple Phase 1 tasks may have modified `electron/main.ts` and `electron/preload.ts`
- Carefully merge handler registrations and API exports
- Ensure no duplicate IPC channel names

## Dos

- ✅ Test all services together, not just individually
- ✅ Verify RLS policies prevent cross-tenant access
- ✅ Ensure consistent error handling
- ✅ Document any gotchas or configuration needed
- ✅ Update README if needed

## Don'ts

- ❌ Don't merge if any tests are failing
- ❌ Don't skip RLS verification
- ❌ Don't leave debug logging in production code
- ❌ Don't break existing functionality

## Testing Instructions

1. Apply all migrations to local Supabase
2. Run unit tests: `npm test`
3. Run integration tests: `npm run test:integration`
4. Run RLS verification: `npx ts-node scripts/verify-rls.ts`
5. Manual testing in Electron app

## PR Preparation Checklist

Before completing, ensure:

- [ ] All Phase 1 tasks merged into this branch
- [ ] All handlers registered
- [ ] Preload bridge complete
- [ ] TypeScript types exported
- [ ] Unit tests passing
- [ ] Integration tests passing
- [ ] RLS verified
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Created pull request with summary

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
