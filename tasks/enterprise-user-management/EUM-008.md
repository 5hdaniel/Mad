# EUM-008: SSO Core Service

## Task Info
- **Task ID:** EUM-008
- **Phase:** 2 - SSO Implementation
- **Dependencies:** EUM-005 (Phase 1 complete)
- **Can Start:** After Phase 1 merge
- **Parallel With:** EUM-006, EUM-007, EUM-009

## Goal

Create the core SSO service that manages SSO configurations, routes login requests to the appropriate provider, and handles SSO enforcement.

## Background

This service acts as the coordinator between the provider-specific services (EUM-006, EUM-007) and the rest of the application. It handles SSO configuration storage, provider detection, and enforcement logic.

## Non-Goals

- ❌ Implementing provider-specific OAuth flows (handled in EUM-006, EUM-007)
- ❌ Building SSO configuration UI (handled in Phase 3)
- ❌ Creating JIT provisioning service (handled in EUM-009)
- ❌ Implementing SCIM provisioning
- ❌ Managing IdP-side configurations
- ❌ Supporting additional SSO providers beyond Entra ID and Google Workspace

## Deliverables

1. SSO core service with configuration management
2. Provider detection and routing
3. SSO enforcement logic
4. Domain verification
5. IPC handlers
6. Unit tests

## Technical Requirements

### 1. Create SSO Types

Create `electron/types/sso.ts`:

```typescript
export type SSOProvider = 'entra_id' | 'google_workspace';

export interface SSOConfiguration {
  id: string;
  organizationId: string;
  provider: SSOProvider;

  // Provider-specific config (one will be populated)
  entraConfig?: {
    tenantId: string;
    clientId: string;
    clientSecretEncrypted: string;
  };
  googleConfig?: {
    domain: string;
    clientId: string;
    clientSecretEncrypted: string;
  };

  // Common settings
  attributeMapping: AttributeMapping;
  isActive: boolean;
  lastTestedAt: string | null;
  testResult: SSOTestResult | null;

  createdAt: string;
  updatedAt: string;
  configuredBy: string | null;
}

export interface AttributeMapping {
  email: string;
  firstName: string;
  lastName: string;
  displayName: string;
  [key: string]: string;
}

export interface SSOTestResult {
  success: boolean;
  error?: string;
  testedAt: string;
}

export interface SSOLoginRequest {
  organizationSlug?: string;
  email?: string;
}

export interface SSOLoginResponse {
  method: 'sso' | 'standard';
  provider?: SSOProvider;
  authUrl?: string;
  state?: string;
  error?: string;
}

export interface ConfigureEntraIdInput {
  organizationId: string;
  tenantId: string;
  clientId: string;
  clientSecret: string;
  configuredBy: string;
}

export interface ConfigureGoogleWorkspaceInput {
  organizationId: string;
  domain: string;
  clientId: string;
  clientSecret: string;
  configuredBy: string;
}
```

### 2. Create SSO Core Service

Create `electron/services/ssoService.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import log from 'electron-log';
import { getEntraIdSsoService } from './entraIdSsoService';
import { getGoogleWorkspaceSsoService } from './googleWorkspaceSsoService';
import { getAuditService } from './auditService';
import { AUDIT_ACTIONS } from '../types/audit';
import type {
  SSOConfiguration,
  SSOProvider,
  SSOLoginRequest,
  SSOLoginResponse,
  ConfigureEntraIdInput,
  ConfigureGoogleWorkspaceInput,
  SSOTestResult,
  AttributeMapping,
} from '../types/sso';

const DEFAULT_ATTRIBUTE_MAPPING: AttributeMapping = {
  email: 'email',
  firstName: 'given_name',
  lastName: 'family_name',
  displayName: 'name',
};

export class SSOService {
  private supabase;
  private entraIdService;
  private googleWorkspaceService;
  private auditService;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
    this.entraIdService = getEntraIdSsoService();
    this.googleWorkspaceService = getGoogleWorkspaceSsoService();
    this.auditService = getAuditService();
  }

  // ==================== Configuration Management ====================

  /**
   * Get SSO configuration for an organization
   */
  async getConfiguration(organizationId: string): Promise<SSOConfiguration | null> {
    const { data, error } = await this.supabase
      .from('sso_configurations')
      .select('*')
      .eq('organization_id', organizationId)
      .single();

    if (error || !data) {
      return null;
    }

    return this.mapToSSOConfiguration(data);
  }

  /**
   * Configure Entra ID SSO for an organization
   */
  async configureEntraId(input: ConfigureEntraIdInput): Promise<SSOConfiguration> {
    // Encrypt client secret
    const clientSecretEncrypted = await this.entraIdService.encryptClientSecret(
      input.clientSecret
    );

    const configData = {
      organization_id: input.organizationId,
      provider: 'entra_id' as SSOProvider,
      entra_tenant_id: input.tenantId,
      entra_client_id: input.clientId,
      entra_client_secret_encrypted: clientSecretEncrypted,
      attribute_mapping: DEFAULT_ATTRIBUTE_MAPPING,
      is_active: false, // Require test before activation
      configured_by: input.configuredBy,
    };

    const { data, error } = await this.supabase
      .from('sso_configurations')
      .upsert(configData, { onConflict: 'organization_id' })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to configure Entra ID: ${error.message}`);
    }

    // Audit log
    await this.auditService.logSSOEvent(
      input.organizationId,
      AUDIT_ACTIONS.SSO_CONFIGURED,
      input.configuredBy,
      '', // Email would come from context
      { provider: 'entra_id' }
    );

    return this.mapToSSOConfiguration(data);
  }

  /**
   * Configure Google Workspace SSO for an organization
   */
  async configureGoogleWorkspace(input: ConfigureGoogleWorkspaceInput): Promise<SSOConfiguration> {
    // Encrypt client secret
    const clientSecretEncrypted = await this.googleWorkspaceService.encryptClientSecret(
      input.clientSecret
    );

    const configData = {
      organization_id: input.organizationId,
      provider: 'google_workspace' as SSOProvider,
      google_workspace_domain: input.domain,
      google_client_id: input.clientId,
      google_client_secret_encrypted: clientSecretEncrypted,
      attribute_mapping: DEFAULT_ATTRIBUTE_MAPPING,
      is_active: false,
      configured_by: input.configuredBy,
    };

    const { data, error } = await this.supabase
      .from('sso_configurations')
      .upsert(configData, { onConflict: 'organization_id' })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to configure Google Workspace: ${error.message}`);
    }

    // Audit log
    await this.auditService.logSSOEvent(
      input.organizationId,
      AUDIT_ACTIONS.SSO_CONFIGURED,
      input.configuredBy,
      '',
      { provider: 'google_workspace', domain: input.domain }
    );

    return this.mapToSSOConfiguration(data);
  }

  /**
   * Test SSO configuration
   */
  async testConfiguration(organizationId: string): Promise<SSOTestResult> {
    const config = await this.getConfiguration(organizationId);

    if (!config) {
      return { success: false, error: 'No SSO configuration found', testedAt: new Date().toISOString() };
    }

    let result: { success: boolean; error?: string };

    if (config.provider === 'entra_id' && config.entraConfig) {
      const clientSecret = await this.entraIdService.decryptClientSecret(
        config.entraConfig.clientSecretEncrypted
      );
      result = await this.entraIdService.testConfiguration({
        tenantId: config.entraConfig.tenantId,
        clientId: config.entraConfig.clientId,
        clientSecret,
        redirectUri: this.getRedirectUri(),
      });
    } else if (config.provider === 'google_workspace' && config.googleConfig) {
      const clientSecret = await this.googleWorkspaceService.decryptClientSecret(
        config.googleConfig.clientSecretEncrypted
      );
      result = await this.googleWorkspaceService.testConfiguration({
        domain: config.googleConfig.domain,
        clientId: config.googleConfig.clientId,
        clientSecret,
        redirectUri: this.getRedirectUri(),
      });
    } else {
      result = { success: false, error: 'Invalid configuration' };
    }

    const testResult: SSOTestResult = {
      ...result,
      testedAt: new Date().toISOString(),
    };

    // Update test result in database
    await this.supabase
      .from('sso_configurations')
      .update({
        last_tested_at: testResult.testedAt,
        test_result: testResult,
      })
      .eq('organization_id', organizationId);

    return testResult;
  }

  /**
   * Enable SSO for an organization
   */
  async enableSSO(organizationId: string, actorId: string): Promise<void> {
    const config = await this.getConfiguration(organizationId);

    if (!config) {
      throw new Error('No SSO configuration found');
    }

    if (!config.testResult?.success) {
      throw new Error('SSO configuration must pass test before enabling');
    }

    await this.supabase
      .from('sso_configurations')
      .update({ is_active: true })
      .eq('organization_id', organizationId);

    await this.supabase
      .from('organizations')
      .update({ sso_enabled: true, sso_provider: config.provider })
      .eq('id', organizationId);

    await this.auditService.logSSOEvent(
      organizationId,
      AUDIT_ACTIONS.SSO_ENABLED,
      actorId,
      '',
      { provider: config.provider }
    );
  }

  /**
   * Disable SSO for an organization
   */
  async disableSSO(organizationId: string, actorId: string): Promise<void> {
    await this.supabase
      .from('sso_configurations')
      .update({ is_active: false })
      .eq('organization_id', organizationId);

    await this.supabase
      .from('organizations')
      .update({ sso_enabled: false, sso_enforced: false })
      .eq('id', organizationId);

    await this.auditService.logSSOEvent(
      organizationId,
      AUDIT_ACTIONS.SSO_DISABLED,
      actorId,
      ''
    );
  }

  /**
   * Set SSO enforcement (block non-SSO login)
   */
  async setSSOEnforcement(organizationId: string, enforced: boolean, actorId: string): Promise<void> {
    await this.supabase
      .from('organizations')
      .update({ sso_enforced: enforced })
      .eq('id', organizationId);

    await this.auditService.logSSOEvent(
      organizationId,
      enforced ? AUDIT_ACTIONS.SSO_ENFORCED : AUDIT_ACTIONS.SSO_UNENFORCED,
      actorId,
      ''
    );
  }

  // ==================== Login Flow ====================

  /**
   * Determine login method based on email or org slug
   */
  async determineLoginMethod(request: SSOLoginRequest): Promise<SSOLoginResponse> {
    let organizationId: string | null = null;

    // Find organization by slug or email domain
    if (request.organizationSlug) {
      const { data: org } = await this.supabase
        .from('organizations')
        .select('id, sso_enabled, sso_enforced')
        .eq('slug', request.organizationSlug)
        .single();

      if (org) {
        organizationId = org.id;
      }
    } else if (request.email) {
      const domain = request.email.split('@')[1];
      const { data: org } = await this.supabase
        .from('organizations')
        .select('id, sso_enabled, sso_enforced')
        .contains('verified_domains', [domain])
        .single();

      if (org) {
        organizationId = org.id;
      }
    }

    if (!organizationId) {
      return { method: 'standard' };
    }

    const config = await this.getConfiguration(organizationId);

    if (!config || !config.isActive) {
      return { method: 'standard' };
    }

    // Get auth URL from appropriate provider
    const state = this.generateState(organizationId);
    let authUrl: string;

    if (config.provider === 'entra_id' && config.entraConfig) {
      const clientSecret = await this.entraIdService.decryptClientSecret(
        config.entraConfig.clientSecretEncrypted
      );
      authUrl = await this.entraIdService.getAuthorizationUrl(
        {
          tenantId: config.entraConfig.tenantId,
          clientId: config.entraConfig.clientId,
          clientSecret,
          redirectUri: this.getRedirectUri(),
        },
        state
      );
    } else if (config.provider === 'google_workspace' && config.googleConfig) {
      const clientSecret = await this.googleWorkspaceService.decryptClientSecret(
        config.googleConfig.clientSecretEncrypted
      );
      authUrl = this.googleWorkspaceService.getAuthorizationUrl(
        {
          domain: config.googleConfig.domain,
          clientId: config.googleConfig.clientId,
          clientSecret,
          redirectUri: this.getRedirectUri(),
        },
        state
      );
    } else {
      return { method: 'standard', error: 'Invalid SSO configuration' };
    }

    return {
      method: 'sso',
      provider: config.provider,
      authUrl,
      state,
    };
  }

  /**
   * Check if SSO is enforced for an organization
   */
  async isSSOEnforced(organizationId: string): Promise<boolean> {
    const { data } = await this.supabase
      .from('organizations')
      .select('sso_enforced')
      .eq('id', organizationId)
      .single();

    return data?.sso_enforced ?? false;
  }

  // ==================== Helpers ====================

  private generateState(organizationId: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2);
    return Buffer.from(JSON.stringify({ organizationId, timestamp, random })).toString('base64url');
  }

  private parseState(state: string): { organizationId: string; timestamp: number } | null {
    try {
      const decoded = Buffer.from(state, 'base64url').toString('utf-8');
      return JSON.parse(decoded);
    } catch {
      return null;
    }
  }

  private getRedirectUri(): string {
    return process.env.SSO_REDIRECT_URI || 'magicaudit://auth/sso/callback';
  }

  private mapToSSOConfiguration(row: any): SSOConfiguration {
    return {
      id: row.id,
      organizationId: row.organization_id,
      provider: row.provider,
      entraConfig: row.entra_tenant_id ? {
        tenantId: row.entra_tenant_id,
        clientId: row.entra_client_id,
        clientSecretEncrypted: row.entra_client_secret_encrypted,
      } : undefined,
      googleConfig: row.google_workspace_domain ? {
        domain: row.google_workspace_domain,
        clientId: row.google_client_id,
        clientSecretEncrypted: row.google_client_secret_encrypted,
      } : undefined,
      attributeMapping: row.attribute_mapping || DEFAULT_ATTRIBUTE_MAPPING,
      isActive: row.is_active,
      lastTestedAt: row.last_tested_at,
      testResult: row.test_result,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      configuredBy: row.configured_by,
    };
  }
}

// Singleton
let ssoService: SSOService | null = null;

export function getSSOService(): SSOService {
  if (!ssoService) {
    ssoService = new SSOService(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    );
  }
  return ssoService;
}
```

### 3. Create IPC Handlers

Create `electron/handlers/ssoHandlers.ts` (structure only - full implementation in integration task)

## Files to Create

- `electron/types/sso.ts`
- `electron/services/ssoService.ts`
- `electron/handlers/ssoHandlers.ts`
- `electron/services/__tests__/ssoService.test.ts`

## Files to Modify

- None (integration in EUM-010)

## Acceptance Criteria

- [ ] `getConfiguration()` retrieves SSO config for organization
- [ ] `configureEntraId()` saves encrypted Entra ID configuration
- [ ] `configureGoogleWorkspace()` saves encrypted Google Workspace configuration
- [ ] `testConfiguration()` validates SSO setup with provider
- [ ] `enableSSO()` only works after successful test
- [ ] `disableSSO()` deactivates SSO and clears enforcement
- [ ] `setSSOEnforcement()` enables/disables SSO enforcement
- [ ] `determineLoginMethod()` routes to correct provider or standard login
- [ ] `isSSOEnforced()` correctly reports enforcement status
- [ ] All SSO events are logged to audit log
- [ ] State parameter is securely generated and validated
- [ ] Unit tests cover all public methods with >80% coverage

## When to Stop and Ask

You MUST stop and ask the PM if:

1. **Provider coordination** - If EUM-006/EUM-007 interfaces don't match expectations
2. **Database schema issues** - If `sso_configurations` table differs from EUM-001
3. **Enforcement edge cases** - If SSO enforcement has unclear behavior for certain flows
4. **Domain detection conflicts** - If user's email matches multiple organizations
5. **State management** - If PKCE/state storage patterns are unclear
6. **Redirect URI configuration** - If redirect URI needs different handling per environment

Do NOT guess or make assumptions. Ask first.

## Integration Notes

### Dependencies
- **EUM-006**: Calls `EntraIdSsoService` for Microsoft authentication
- **EUM-007**: Calls `GoogleWorkspaceSsoService` for Google authentication
- **EUM-003**: Uses `AuditService` for logging SSO events

### For EUM-009 (JIT Provisioning)
- After successful SSO login, SSO Core returns user info
- JIT service receives this info to create/update user

### For EUM-010 (Integration Task)
- SSO Core must expose IPC handlers for configuration and login
- Coordinate state management across all SSO services

### For Phase 3 (Admin Portal)
- SSO configuration UI will call these IPC handlers
- Test results are stored for display in admin portal

## Dos

- ✅ Coordinate between provider services
- ✅ Manage SSO state securely
- ✅ Validate configurations before enabling
- ✅ Log all SSO events to audit log

## Don'ts

- ❌ Don't enable SSO without successful test
- ❌ Don't store decrypted secrets in memory longer than needed
- ❌ Don't skip domain verification

## PR Preparation Checklist

Before completing, ensure all items are checked and tests pass.

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
