# EUM-009: JIT User Provisioning Service

## Task Info
- **Task ID:** EUM-009
- **Phase:** 2 - SSO Implementation
- **Dependencies:** EUM-005 (Phase 1 complete)
- **Can Start:** After Phase 1 merge
- **Parallel With:** EUM-006, EUM-007, EUM-008

## Goal

Create a Just-In-Time (JIT) provisioning service that automatically creates or updates user accounts when they first log in via SSO.

## Background

When a user authenticates via SSO for the first time, we need to:
1. Check if they already exist in our system
2. If not, create their account automatically
3. Add them to the appropriate organization
4. Map IdP attributes to our user model

## Non-Goals

- ❌ Implementing SSO authentication flows (handled in EUM-006, EUM-007, EUM-008)
- ❌ Building user management UI
- ❌ Implementing SCIM provisioning (handled in Phase 4)
- ❌ Managing user deprovisioning (handled separately)
- ❌ Role mapping from IdP groups (future enhancement)
- ❌ Custom attribute mapping UI

## Deliverables

1. JIT provisioning service
2. Attribute mapping from IdP claims to user model
3. User creation/update logic
4. Organization membership management
5. Unit tests

## Technical Requirements

### 1. Create JIT Types

Create `electron/types/jitProvisioning.ts`:

```typescript
export interface IdPUserAttributes {
  id: string;
  email: string;
  displayName?: string;
  firstName?: string;
  lastName?: string;
  avatarUrl?: string;
  groups?: string[];
  [key: string]: any;
}

export interface ProvisioningResult {
  success: boolean;
  userId?: string;
  isNewUser: boolean;
  error?: string;
}

export interface ProvisioningOptions {
  organizationId: string;
  provider: 'entra_id' | 'google_workspace';
  defaultRole?: 'admin' | 'member';
  updateExisting?: boolean;
}
```

### 2. Create JIT Provisioning Service

Create `electron/services/jitProvisioningService.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import log from 'electron-log';
import { getOrganizationService } from './organizationService';
import { getAuditService } from './auditService';
import { AUDIT_ACTIONS } from '../types/audit';
import type {
  IdPUserAttributes,
  ProvisioningResult,
  ProvisioningOptions,
} from '../types/jitProvisioning';
import type { AttributeMapping } from '../types/sso';

export class JITProvisioningService {
  private supabase;
  private orgService;
  private auditService;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
    this.orgService = getOrganizationService();
    this.auditService = getAuditService();
  }

  /**
   * Provision user from SSO login
   */
  async provisionUser(
    attributes: IdPUserAttributes,
    options: ProvisioningOptions,
    attributeMapping?: AttributeMapping
  ): Promise<ProvisioningResult> {
    try {
      // Map IdP attributes to our user model
      const mappedUser = this.mapAttributes(attributes, attributeMapping);

      // Check if user exists
      const existingUser = await this.findUserByEmail(mappedUser.email);

      if (existingUser) {
        // Update existing user if option enabled
        if (options.updateExisting) {
          await this.updateUser(existingUser.id, mappedUser);
        }

        // Ensure user is member of organization
        await this.ensureOrgMembership(existingUser.id, options.organizationId, options.defaultRole);

        return {
          success: true,
          userId: existingUser.id,
          isNewUser: false,
        };
      }

      // Create new user
      const newUser = await this.createUser(mappedUser, options.provider);

      // Add to organization
      await this.addToOrganization(newUser.id, options.organizationId, options.defaultRole);

      // Audit log
      await this.auditService.log({
        organizationId: options.organizationId,
        actorType: 'system',
        action: AUDIT_ACTIONS.SCIM_USER_PROVISIONED,
        resourceType: 'user',
        resourceId: newUser.id,
        details: {
          email: mappedUser.email,
          provider: options.provider,
          method: 'jit',
        },
      });

      return {
        success: true,
        userId: newUser.id,
        isNewUser: true,
      };
    } catch (error) {
      log.error('JIT provisioning failed:', error);
      return {
        success: false,
        isNewUser: false,
        error: error instanceof Error ? error.message : 'Provisioning failed',
      };
    }
  }

  /**
   * Map IdP attributes to our user model
   */
  private mapAttributes(
    attributes: IdPUserAttributes,
    mapping?: AttributeMapping
  ): {
    email: string;
    displayName: string;
    firstName: string | null;
    lastName: string | null;
    avatarUrl: string | null;
    oauthId: string;
  } {
    const m = mapping || {
      email: 'email',
      firstName: 'firstName',
      lastName: 'lastName',
      displayName: 'displayName',
    };

    return {
      email: attributes[m.email] || attributes.email,
      displayName: attributes[m.displayName] || attributes.displayName || attributes.email,
      firstName: attributes[m.firstName] || attributes.firstName || null,
      lastName: attributes[m.lastName] || attributes.lastName || null,
      avatarUrl: attributes.avatarUrl || null,
      oauthId: attributes.id,
    };
  }

  private async findUserByEmail(email: string) {
    const { data } = await this.supabase
      .from('users')
      .select('id, email')
      .eq('email', email.toLowerCase())
      .single();
    return data;
  }

  private async createUser(userData: any, provider: string) {
    const { data, error } = await this.supabase
      .from('users')
      .insert({
        email: userData.email.toLowerCase(),
        display_name: userData.displayName,
        first_name: userData.firstName,
        last_name: userData.lastName,
        avatar_url: userData.avatarUrl,
        oauth_provider: provider === 'entra_id' ? 'microsoft' : 'google',
        oauth_id: userData.oauthId,
        subscription_tier: 'enterprise',
        is_active: true,
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  private async updateUser(userId: string, userData: any) {
    await this.supabase
      .from('users')
      .update({
        display_name: userData.displayName,
        first_name: userData.firstName,
        last_name: userData.lastName,
        avatar_url: userData.avatarUrl,
      })
      .eq('id', userId);
  }

  private async ensureOrgMembership(userId: string, orgId: string, role?: string) {
    const existing = await this.orgService.getMember(orgId, userId);
    if (!existing) {
      await this.addToOrganization(userId, orgId, role);
    }
  }

  private async addToOrganization(userId: string, orgId: string, role?: string) {
    await this.supabase.from('organization_members').insert({
      organization_id: orgId,
      user_id: userId,
      role: role || 'member',
      status: 'active',
      provisioned_by: 'sso_jit',
    });
  }
}

// Singleton
let jitService: JITProvisioningService | null = null;

export function getJITProvisioningService(): JITProvisioningService {
  if (!jitService) {
    jitService = new JITProvisioningService(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    );
  }
  return jitService;
}
```

## Files to Create

- `electron/types/jitProvisioning.ts`
- `electron/services/jitProvisioningService.ts`
- `electron/services/__tests__/jitProvisioningService.test.ts`

## Dos

- ✅ Handle both new and existing users
- ✅ Use attribute mapping for flexibility
- ✅ Set `provisioned_by: 'sso_jit'` for tracking
- ✅ Log all provisioning events to audit log
- ✅ Check seat availability before creating new users

## Don'ts

- ❌ Don't create users without valid email
- ❌ Don't overwrite existing user data without `updateExisting` flag
- ❌ Don't add users to organizations they're already members of
- ❌ Don't log sensitive user data to console

## Acceptance Criteria

- [ ] `provisionUser()` creates new user on first SSO login
- [ ] `provisionUser()` recognizes existing users by email
- [ ] `provisionUser()` updates user attributes when `updateExisting: true`
- [ ] `provisionUser()` adds user to organization as member (default role)
- [ ] `provisionUser()` respects seat limits
- [ ] Attribute mapping correctly maps IdP claims to user fields
- [ ] Existing org membership is preserved (no duplicates)
- [ ] All provisioning events are logged to audit log
- [ ] Unit tests cover all public methods with >80% coverage

## When to Stop and Ask

You MUST stop and ask the PM if:

1. **Users table structure** - If the existing `users` table doesn't match expected columns
2. **Seat limit handling** - If seat limits need different error handling than rejection
3. **Attribute conflicts** - If IdP attributes conflict with existing user data
4. **Email uniqueness** - If email normalization (case, aliases) needs special handling
5. **OAuth ID conflicts** - If user has different OAuth ID than stored
6. **Role assignment** - If default role should be configurable per organization

Do NOT guess or make assumptions. Ask first.

## Integration Notes

### Dependencies
- **EUM-002**: Uses `OrganizationService` for membership management
- **EUM-003**: Uses `AuditService` for provisioning event logging

### For EUM-008 (SSO Core)
- SSO Core calls JIT service after successful authentication
- Receives user attributes from SSO provider

### For EUM-010 (Integration Task)
- JIT service is called internally, no direct IPC handlers
- Must work with both Entra ID and Google Workspace user attributes

### For Phase 4 (SCIM)
- SCIM provisioning is separate but complementary to JIT
- Same `provisioned_by` column tracks provisioning source

## PR Preparation Checklist

- [ ] Service handles new and existing users
- [ ] Attribute mapping works correctly
- [ ] Audit logging in place
- [ ] Unit tests with >80% coverage
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`

## Work Summary

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED]
```

### Testing Done
```
[DESCRIBE TESTING PERFORMED]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
