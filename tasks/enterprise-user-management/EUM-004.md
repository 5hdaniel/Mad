# EUM-004: RBAC Service

## Task Info
- **Task ID:** EUM-004
- **Phase:** 1 - Foundation
- **Dependencies:** None (can work with mock data until EUM-001 is merged)
- **Can Start:** Immediately
- **Parallel With:** EUM-001, EUM-002, EUM-003

## Goal

Create a Role-Based Access Control (RBAC) service that manages permissions for organization members based on their roles.

## Background

Organizations have three roles: `owner`, `admin`, and `member`. Each role has different permissions for managing the organization, users, SSO, and other features.

## Deliverables

1. RBAC service with permission checking
2. TypeScript types for roles and permissions
3. Permission matrix implementation
4. Middleware/decorator patterns for IPC handlers
5. Unit tests

## Technical Requirements

### 1. Create RBAC Types

Create `electron/types/rbac.ts`:

```typescript
// Roles
export const ROLES = {
  OWNER: 'owner',
  ADMIN: 'admin',
  MEMBER: 'member',
} as const;

export type Role = typeof ROLES[keyof typeof ROLES];

// Permissions
export const PERMISSIONS = {
  // Organization
  ORG_VIEW: 'org.view',
  ORG_EDIT: 'org.edit',
  ORG_DELETE: 'org.delete',

  // Members
  MEMBERS_VIEW: 'members.view',
  MEMBERS_INVITE: 'members.invite',
  MEMBERS_REMOVE: 'members.remove',
  MEMBERS_EDIT_ROLE: 'members.edit_role',
  MEMBERS_SUSPEND: 'members.suspend',

  // SSO
  SSO_VIEW: 'sso.view',
  SSO_CONFIGURE: 'sso.configure',
  SSO_ENABLE: 'sso.enable',
  SSO_ENFORCE: 'sso.enforce',

  // SCIM
  SCIM_VIEW: 'scim.view',
  SCIM_CONFIGURE: 'scim.configure',
  SCIM_MANAGE_TOKENS: 'scim.manage_tokens',

  // Audit Logs
  AUDIT_VIEW: 'audit.view',
  AUDIT_EXPORT: 'audit.export',

  // Billing (owner only)
  BILLING_VIEW: 'billing.view',
  BILLING_MANAGE: 'billing.manage',

  // Ownership
  OWNERSHIP_TRANSFER: 'ownership.transfer',
} as const;

export type Permission = typeof PERMISSIONS[keyof typeof PERMISSIONS];

// Permission check result
export interface PermissionCheckResult {
  allowed: boolean;
  reason?: string;
}

// User context for permission checks
export interface UserContext {
  userId: string;
  organizationId: string;
  role?: Role;
}
```

### 2. Create Permission Matrix

Create `electron/services/rbac/permissionMatrix.ts`:

```typescript
import { ROLES, PERMISSIONS, Role, Permission } from '../../types/rbac';

/**
 * Permission matrix defining which roles have which permissions
 */
export const PERMISSION_MATRIX: Record<Role, Permission[]> = {
  [ROLES.OWNER]: [
    // Organization - full access
    PERMISSIONS.ORG_VIEW,
    PERMISSIONS.ORG_EDIT,
    PERMISSIONS.ORG_DELETE,

    // Members - full access
    PERMISSIONS.MEMBERS_VIEW,
    PERMISSIONS.MEMBERS_INVITE,
    PERMISSIONS.MEMBERS_REMOVE,
    PERMISSIONS.MEMBERS_EDIT_ROLE,
    PERMISSIONS.MEMBERS_SUSPEND,

    // SSO - full access
    PERMISSIONS.SSO_VIEW,
    PERMISSIONS.SSO_CONFIGURE,
    PERMISSIONS.SSO_ENABLE,
    PERMISSIONS.SSO_ENFORCE,

    // SCIM - full access
    PERMISSIONS.SCIM_VIEW,
    PERMISSIONS.SCIM_CONFIGURE,
    PERMISSIONS.SCIM_MANAGE_TOKENS,

    // Audit - full access
    PERMISSIONS.AUDIT_VIEW,
    PERMISSIONS.AUDIT_EXPORT,

    // Billing - owner only
    PERMISSIONS.BILLING_VIEW,
    PERMISSIONS.BILLING_MANAGE,

    // Ownership - owner only
    PERMISSIONS.OWNERSHIP_TRANSFER,
  ],

  [ROLES.ADMIN]: [
    // Organization - view and edit
    PERMISSIONS.ORG_VIEW,
    PERMISSIONS.ORG_EDIT,

    // Members - full access except role changes to owner
    PERMISSIONS.MEMBERS_VIEW,
    PERMISSIONS.MEMBERS_INVITE,
    PERMISSIONS.MEMBERS_REMOVE,
    PERMISSIONS.MEMBERS_EDIT_ROLE,
    PERMISSIONS.MEMBERS_SUSPEND,

    // SSO - full access
    PERMISSIONS.SSO_VIEW,
    PERMISSIONS.SSO_CONFIGURE,
    PERMISSIONS.SSO_ENABLE,
    PERMISSIONS.SSO_ENFORCE,

    // SCIM - full access
    PERMISSIONS.SCIM_VIEW,
    PERMISSIONS.SCIM_CONFIGURE,
    PERMISSIONS.SCIM_MANAGE_TOKENS,

    // Audit - full access
    PERMISSIONS.AUDIT_VIEW,
    PERMISSIONS.AUDIT_EXPORT,

    // Billing - view only
    PERMISSIONS.BILLING_VIEW,
  ],

  [ROLES.MEMBER]: [
    // Organization - view only
    PERMISSIONS.ORG_VIEW,

    // Members - view only
    PERMISSIONS.MEMBERS_VIEW,
  ],
};

/**
 * Check if a role has a specific permission
 */
export function roleHasPermission(role: Role, permission: Permission): boolean {
  return PERMISSION_MATRIX[role]?.includes(permission) ?? false;
}

/**
 * Get all permissions for a role
 */
export function getPermissionsForRole(role: Role): Permission[] {
  return PERMISSION_MATRIX[role] ?? [];
}

/**
 * Get the minimum role required for a permission
 */
export function getMinimumRoleForPermission(permission: Permission): Role | null {
  if (roleHasPermission(ROLES.MEMBER, permission)) return ROLES.MEMBER;
  if (roleHasPermission(ROLES.ADMIN, permission)) return ROLES.ADMIN;
  if (roleHasPermission(ROLES.OWNER, permission)) return ROLES.OWNER;
  return null;
}
```

### 3. Create RBAC Service

Create `electron/services/rbacService.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import log from 'electron-log';
import type {
  Role,
  Permission,
  PermissionCheckResult,
  UserContext,
} from '../types/rbac';
import { ROLES, PERMISSIONS } from '../types/rbac';
import { roleHasPermission, getPermissionsForRole } from './rbac/permissionMatrix';

export class RBACService {
  private supabase;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  /**
   * Get user's role in an organization
   */
  async getUserRole(userId: string, organizationId: string): Promise<Role | null> {
    const { data, error } = await this.supabase
      .from('organization_members')
      .select('role')
      .eq('user_id', userId)
      .eq('organization_id', organizationId)
      .eq('status', 'active')
      .single();

    if (error || !data) {
      return null;
    }

    return data.role as Role;
  }

  /**
   * Check if user has a specific permission
   */
  async hasPermission(
    userId: string,
    organizationId: string,
    permission: Permission
  ): Promise<PermissionCheckResult> {
    const role = await this.getUserRole(userId, organizationId);

    if (!role) {
      return {
        allowed: false,
        reason: 'User is not a member of this organization',
      };
    }

    const allowed = roleHasPermission(role, permission);

    return {
      allowed,
      reason: allowed
        ? undefined
        : `Role '${role}' does not have permission '${permission}'`,
    };
  }

  /**
   * Check multiple permissions at once
   */
  async hasPermissions(
    userId: string,
    organizationId: string,
    permissions: Permission[]
  ): Promise<Record<Permission, PermissionCheckResult>> {
    const role = await this.getUserRole(userId, organizationId);
    const results: Record<string, PermissionCheckResult> = {};

    for (const permission of permissions) {
      if (!role) {
        results[permission] = {
          allowed: false,
          reason: 'User is not a member of this organization',
        };
      } else {
        const allowed = roleHasPermission(role, permission);
        results[permission] = {
          allowed,
          reason: allowed
            ? undefined
            : `Role '${role}' does not have permission '${permission}'`,
        };
      }
    }

    return results as Record<Permission, PermissionCheckResult>;
  }

  /**
   * Get all permissions for a user in an organization
   */
  async getUserPermissions(
    userId: string,
    organizationId: string
  ): Promise<Permission[]> {
    const role = await this.getUserRole(userId, organizationId);

    if (!role) {
      return [];
    }

    return getPermissionsForRole(role);
  }

  /**
   * Check if user is an admin or owner
   */
  async isAdminOrOwner(userId: string, organizationId: string): Promise<boolean> {
    const role = await this.getUserRole(userId, organizationId);
    return role === ROLES.OWNER || role === ROLES.ADMIN;
  }

  /**
   * Check if user is the owner
   */
  async isOwner(userId: string, organizationId: string): Promise<boolean> {
    const role = await this.getUserRole(userId, organizationId);
    return role === ROLES.OWNER;
  }

  /**
   * Check if user can manage another user (role hierarchy)
   */
  async canManageUser(
    actorId: string,
    targetUserId: string,
    organizationId: string
  ): Promise<PermissionCheckResult> {
    // Users can't manage themselves through this
    if (actorId === targetUserId) {
      return {
        allowed: false,
        reason: 'Cannot manage yourself through this action',
      };
    }

    const actorRole = await this.getUserRole(actorId, organizationId);
    const targetRole = await this.getUserRole(targetUserId, organizationId);

    if (!actorRole) {
      return {
        allowed: false,
        reason: 'Actor is not a member of this organization',
      };
    }

    if (!targetRole) {
      return {
        allowed: false,
        reason: 'Target user is not a member of this organization',
      };
    }

    // Only owners can manage other owners
    if (targetRole === ROLES.OWNER) {
      return {
        allowed: false,
        reason: 'Cannot manage organization owner',
      };
    }

    // Admins can manage members but not other admins
    if (actorRole === ROLES.ADMIN && targetRole === ROLES.ADMIN) {
      return {
        allowed: false,
        reason: 'Admins cannot manage other admins',
      };
    }

    // Members can't manage anyone
    if (actorRole === ROLES.MEMBER) {
      return {
        allowed: false,
        reason: 'Members cannot manage other users',
      };
    }

    return { allowed: true };
  }

  /**
   * Check if user can assign a specific role
   */
  async canAssignRole(
    actorId: string,
    organizationId: string,
    targetRole: Role
  ): Promise<PermissionCheckResult> {
    const actorRole = await this.getUserRole(actorId, organizationId);

    if (!actorRole) {
      return {
        allowed: false,
        reason: 'Actor is not a member of this organization',
      };
    }

    // Only owners can assign owner role
    if (targetRole === ROLES.OWNER) {
      return {
        allowed: false,
        reason: 'Owner role can only be transferred, not assigned',
      };
    }

    // Admins can assign member role
    if (actorRole === ROLES.ADMIN && targetRole === ROLES.MEMBER) {
      return { allowed: true };
    }

    // Owners can assign admin or member roles
    if (actorRole === ROLES.OWNER) {
      return { allowed: true };
    }

    return {
      allowed: false,
      reason: `Role '${actorRole}' cannot assign role '${targetRole}'`,
    };
  }

  /**
   * Require permission - throws error if not allowed
   */
  async requirePermission(
    userId: string,
    organizationId: string,
    permission: Permission
  ): Promise<void> {
    const result = await this.hasPermission(userId, organizationId, permission);

    if (!result.allowed) {
      throw new Error(result.reason || 'Permission denied');
    }
  }
}

// Singleton instance
let rbacService: RBACService | null = null;

export function getRBACService(): RBACService {
  if (!rbacService) {
    rbacService = new RBACService(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    );
  }
  return rbacService;
}
```

### 4. Create Permission Check Middleware

Create `electron/middleware/requirePermission.ts`:

```typescript
import { IpcMainInvokeEvent } from 'electron';
import { getRBACService } from '../services/rbacService';
import { Permission } from '../types/rbac';
import log from 'electron-log';

type IpcHandler<T = any> = (
  event: IpcMainInvokeEvent,
  ...args: any[]
) => Promise<T>;

interface ProtectedHandlerOptions {
  permission: Permission;
  getOrgId: (...args: any[]) => string;
  getUserId: (...args: any[]) => string;
}

/**
 * Wrap an IPC handler with permission checking
 */
export function withPermission<T>(
  handler: IpcHandler<T>,
  options: ProtectedHandlerOptions
): IpcHandler<{ success: boolean; data?: T; error?: string }> {
  return async (event, ...args) => {
    const rbacService = getRBACService();

    const orgId = options.getOrgId(...args);
    const userId = options.getUserId(...args);

    try {
      await rbacService.requirePermission(userId, orgId, options.permission);
      const result = await handler(event, ...args);
      return { success: true, data: result };
    } catch (error) {
      log.warn(`Permission denied: ${options.permission} for user ${userId} in org ${orgId}`);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Permission denied',
      };
    }
  };
}

/**
 * Check permission before executing - returns result object
 */
export async function checkPermissionAndExecute<T>(
  userId: string,
  orgId: string,
  permission: Permission,
  action: () => Promise<T>
): Promise<{ success: boolean; data?: T; error?: string }> {
  const rbacService = getRBACService();

  try {
    await rbacService.requirePermission(userId, orgId, permission);
    const result = await action();
    return { success: true, data: result };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Permission denied',
    };
  }
}
```

### 5. Create IPC Handlers

Create `electron/handlers/rbacHandlers.ts`:

```typescript
import { ipcMain } from 'electron';
import { getRBACService } from '../services/rbacService';
import log from 'electron-log';

export function registerRBACHandlers(): void {
  const rbacService = getRBACService();

  ipcMain.handle('rbac:get-role', async (_, userId, orgId) => {
    try {
      const role = await rbacService.getUserRole(userId, orgId);
      return { success: true, data: role };
    } catch (error) {
      log.error('Failed to get user role:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('rbac:has-permission', async (_, userId, orgId, permission) => {
    try {
      const result = await rbacService.hasPermission(userId, orgId, permission);
      return { success: true, data: result };
    } catch (error) {
      log.error('Failed to check permission:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('rbac:get-permissions', async (_, userId, orgId) => {
    try {
      const permissions = await rbacService.getUserPermissions(userId, orgId);
      return { success: true, data: permissions };
    } catch (error) {
      log.error('Failed to get permissions:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('rbac:is-admin-or-owner', async (_, userId, orgId) => {
    try {
      const result = await rbacService.isAdminOrOwner(userId, orgId);
      return { success: true, data: result };
    } catch (error) {
      log.error('Failed to check admin status:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('rbac:can-manage-user', async (_, actorId, targetUserId, orgId) => {
    try {
      const result = await rbacService.canManageUser(actorId, targetUserId, orgId);
      return { success: true, data: result };
    } catch (error) {
      log.error('Failed to check can manage user:', error);
      return { success: false, error: error.message };
    }
  });
}
```

### 6. Update Preload Script

Add to `electron/preload.ts`:

```typescript
rbac: {
  getRole: (userId: string, orgId: string) =>
    ipcRenderer.invoke('rbac:get-role', userId, orgId),
  hasPermission: (userId: string, orgId: string, permission: string) =>
    ipcRenderer.invoke('rbac:has-permission', userId, orgId, permission),
  getPermissions: (userId: string, orgId: string) =>
    ipcRenderer.invoke('rbac:get-permissions', userId, orgId),
  isAdminOrOwner: (userId: string, orgId: string) =>
    ipcRenderer.invoke('rbac:is-admin-or-owner', userId, orgId),
  canManageUser: (actorId: string, targetUserId: string, orgId: string) =>
    ipcRenderer.invoke('rbac:can-manage-user', actorId, targetUserId, orgId),
},
```

## Files to Create

- `electron/types/rbac.ts`
- `electron/services/rbac/permissionMatrix.ts`
- `electron/services/rbacService.ts`
- `electron/middleware/requirePermission.ts`
- `electron/handlers/rbacHandlers.ts`
- `electron/services/__tests__/rbacService.test.ts`

## Files to Modify

- `electron/preload.ts` - Add rbac API
- `electron/main.ts` - Register rbac handlers
- `src/types/electron.d.ts` - Add rbac types

## Permission Matrix Summary

| Permission | Owner | Admin | Member |
|------------|-------|-------|--------|
| org.view | ✓ | ✓ | ✓ |
| org.edit | ✓ | ✓ | ✗ |
| org.delete | ✓ | ✗ | ✗ |
| members.view | ✓ | ✓ | ✓ |
| members.invite | ✓ | ✓ | ✗ |
| members.remove | ✓ | ✓ | ✗ |
| members.edit_role | ✓ | ✓ | ✗ |
| members.suspend | ✓ | ✓ | ✗ |
| sso.view | ✓ | ✓ | ✗ |
| sso.configure | ✓ | ✓ | ✗ |
| sso.enable | ✓ | ✓ | ✗ |
| sso.enforce | ✓ | ✓ | ✗ |
| scim.view | ✓ | ✓ | ✗ |
| scim.configure | ✓ | ✓ | ✗ |
| scim.manage_tokens | ✓ | ✓ | ✗ |
| audit.view | ✓ | ✓ | ✗ |
| audit.export | ✓ | ✓ | ✗ |
| billing.view | ✓ | ✓ | ✗ |
| billing.manage | ✓ | ✗ | ✗ |
| ownership.transfer | ✓ | ✗ | ✗ |

## Dos

- ✅ Use constants for roles and permissions
- ✅ Make permission checks fast (cache if needed)
- ✅ Provide clear error messages
- ✅ Support checking multiple permissions at once
- ✅ Create middleware for easy handler protection

## Don'ts

- ❌ Don't hardcode permission checks in handlers
- ❌ Don't allow role escalation
- ❌ Don't allow users to manage owners
- ❌ Don't expose internal role hierarchy details

## Testing Instructions

1. Unit test permission matrix
2. Test role hierarchy enforcement
3. Test permission checks for all roles
4. Test edge cases (non-member, suspended user)
5. Test middleware wrapper

## PR Preparation Checklist

Before completing, ensure:

- [ ] Permission matrix is complete and correct
- [ ] All methods have error handling
- [ ] Unit tests with >80% coverage
- [ ] Type check passes: `npm run type-check`
- [ ] Lint check passes: `npm run lint`
- [ ] Tests pass: `npm test`
- [ ] Created pull request with summary

## Work Summary

> **Instructions:** Update this section when your work is complete.

### Branch Name
```
[FILL IN YOUR BRANCH NAME HERE]
```

### Changes Made
```
[LIST THE FILES YOU MODIFIED AND WHAT YOU CHANGED]
```

### Testing Done
```
[DESCRIBE WHAT TESTING YOU PERFORMED]
```

### Notes/Issues Encountered
```
[ANY ISSUES OR NOTES FOR THE REVIEWER]
```

### PR Link
```
[LINK TO YOUR PULL REQUEST]
```
